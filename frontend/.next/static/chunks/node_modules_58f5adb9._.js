(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports._ = _interop_require_default;
}}),
"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
exports._ = _interop_require_wildcard;
}}),
"[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_base.cjs [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _class_private_field_loose_base(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
}
exports._ = _class_private_field_loose_base;
}}),
"[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_key.cjs [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var id = 0;
function _class_private_field_loose_key(name) {
    return "__private_" + id++ + "_" + name;
}
exports._ = _class_private_field_loose_key;
}}),
"[project]/node_modules/@swc/helpers/cjs/_tagged_template_literal_loose.cjs [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _tagged_template_literal_loose(strings, raw) {
    if (!raw) raw = strings.slice(0);
    strings.raw = raw;
    return strings;
}
exports._ = _tagged_template_literal_loose;
}}),
"[project]/node_modules/react/cjs/react.development.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
            get: function() {
                console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
            }
        });
    }
    function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = !0);
    }
    function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement(oldElement.type, newKey, void 0, void 0, oldElement._owner, oldElement.props, oldElement._debugStack, oldElement._debugTask);
        oldElement._store && (newKey._store.validated = oldElement._store.validated);
        return newKey;
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
        var escaperLookup = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + key.replace(/[=:]/g, function(match) {
            return escaperLookup[match];
        });
    }
    function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
    }
    function noop$1() {}
    function resolveThenable(thenable) {
        switch(thenable.status){
            case "fulfilled":
                return thenable.value;
            case "rejected":
                throw thenable.reason;
            default:
                switch("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
                    "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                }, function(error) {
                    "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                })), thenable.status){
                    case "fulfilled":
                        return thenable.value;
                    case "rejected":
                        throw thenable.reason;
                }
        }
        throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = !1;
        if (null === children) invokeCallback = !0;
        else switch(type){
            case "bigint":
            case "string":
            case "number":
                invokeCallback = !0;
                break;
            case "object":
                switch(children.$$typeof){
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                        invokeCallback = !0;
                        break;
                    case REACT_LAZY_TYPE:
                        return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
                }
        }
        if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
                return c;
            })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children)) for(var i = 0; i < children.length; i++)nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
        else if (i = getIteratorFn(children), "function" === typeof i) for(i === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0), children = i.call(children), i = 0; !(nameSoFar = children.next()).done;)nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
        else if ("object" === type) {
            if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
            array = String(children);
            throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
        }
        return invokeCallback;
    }
    function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
        });
        return result;
    }
    function lazyInitializer(payload) {
        if (-1 === payload._status) {
            var ctor = payload._result;
            ctor = ctor();
            ctor.then(function(moduleObject) {
                if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
            }, function(error) {
                if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
            });
            -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return ctor = payload._result, void 0 === ctor && console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", ctor), "default" in ctor || console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", ctor), ctor.default;
        throw payload._result;
    }
    function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
        return dispatcher;
    }
    function noop() {}
    function enqueueTask(task) {
        if (null === enqueueTaskImpl) try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
        } catch (_err) {
            enqueueTaskImpl = function(callback) {
                !1 === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = !0, "undefined" === typeof MessageChannel && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
            };
        }
        return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
        actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue) if (0 !== queue.length) try {
            flushActQueue(queue);
            enqueueTask(function() {
                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
            return;
        } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
        }
        else ReactSharedInternals.actQueue = null;
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
    }
    function flushActQueue(queue) {
        if (!isFlushing) {
            isFlushing = !0;
            var i = 0;
            try {
                for(; i < queue.length; i++){
                    var callback = queue[i];
                    do {
                        ReactSharedInternals.didUsePromise = !1;
                        var continuation = callback(!1);
                        if (null !== continuation) {
                            if (ReactSharedInternals.didUsePromise) {
                                queue[i] = callback;
                                queue.splice(0, i);
                                return;
                            }
                            callback = continuation;
                        } else break;
                    }while (1)
                }
                queue.length = 0;
            } catch (error) {
                queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally{
                isFlushing = !1;
            }
        }
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: function() {
            return !1;
        },
        enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
        }
    }, assign = Object.assign, emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
        isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
    }, fnName;
    for(fnName in deprecatedAPIs)deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = !0;
    var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
    }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    deprecatedAPIs = {
        "react-stack-bottom-frame": function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = deprecatedAPIs["react-stack-bottom-frame"].bind(deprecatedAPIs, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutMaps = !1, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
                error: error
            });
            if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] && "function" === typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].emit) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].emit("uncaughtException", error);
            return;
        }
        console.error(error);
    }, didWarnAboutMessageChannel = !1, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = !1, isFlushing = !1, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
            return queueMicrotask(callback);
        });
    } : enqueueTask;
    deprecatedAPIs = Object.freeze({
        __proto__: null,
        c: function(size) {
            return resolveDispatcher().useMemoCache(size);
        }
    });
    exports.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
                forEachFunc.apply(this, arguments);
            }, forEachContext);
        },
        count: function(children) {
            var n = 0;
            mapChildren(children, function() {
                n++;
            });
            return n;
        },
        toArray: function(children) {
            return mapChildren(children, function(child) {
                return child;
            }) || [];
        },
        only: function(children) {
            if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
            return children;
        }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = deprecatedAPIs;
    exports.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = !1;
        try {
            var result = callback();
        } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
        }
        if (0 < ReactSharedInternals.thrownErrors.length) throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
                didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            });
            return {
                then: function(resolve, reject) {
                    didAwaitActCall = !0;
                    thenable.then(function(returnValue) {
                        popActScope(prevActQueue, prevActScopeDepth);
                        if (0 === prevActScopeDepth) {
                            try {
                                flushActQueue(queue), enqueueTask(function() {
                                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                                });
                            } catch (error$0) {
                                ReactSharedInternals.thrownErrors.push(error$0);
                            }
                            if (0 < ReactSharedInternals.thrownErrors.length) {
                                var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                                ReactSharedInternals.thrownErrors.length = 0;
                                reject(_thrownError);
                            }
                        } else resolve(returnValue);
                    }, function(error) {
                        popActScope(prevActQueue, prevActScopeDepth);
                        0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                    });
                }
            };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length) throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
            then: function(resolve, reject) {
                didAwaitActCall = !0;
                0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                    return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);
                })) : resolve(returnValue$jscomp$0);
            }
        };
    };
    exports.cache = function(fn) {
        return function() {
            return fn.apply(null, arguments);
        };
    };
    exports.captureOwnerStack = function() {
        var getCurrentStack = ReactSharedInternals.getCurrentStack;
        return null === getCurrentStack ? null : getCurrentStack();
    };
    exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
        var props = assign({}, element.props), key = element.key, owner = element._owner;
        if (null != config) {
            var JSCompiler_inline_result;
            a: {
                if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config, "ref").get) && JSCompiler_inline_result.isReactWarning) {
                    JSCompiler_inline_result = !1;
                    break a;
                }
                JSCompiler_inline_result = void 0 !== config.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
            for(propName in config)!hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for(var i = 0; i < propName; i++)JSCompiler_inline_result[i] = arguments[i + 2];
            props.children = JSCompiler_inline_result;
        }
        props = ReactElement(element.type, key, void 0, void 0, owner, props, element._debugStack, element._debugTask);
        for(key = 2; key < arguments.length; key++)owner = arguments[key], isValidElement(owner) && owner._store && (owner._store.validated = 1);
        return props;
    };
    exports.createContext = function(defaultValue) {
        defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
    };
    exports.createElement = function(type, config, children) {
        for(var i = 2; i < arguments.length; i++){
            var node = arguments[i];
            isValidElement(node) && node._store && (node._store.validated = 1);
        }
        i = {};
        node = null;
        if (null != config) for(propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = !0, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = "" + config.key), config)hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) i.children = children;
        else if (1 < childrenLength) {
            for(var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i.children = childArray;
        }
        if (type && type.defaultProps) for(propName in childrenLength = type.defaultProps, childrenLength)void 0 === i[propName] && (i[propName] = childrenLength[propName]);
        node && defineKeyPropWarningGetter(i, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return ReactElement(type, node, void 0, void 0, getOwner(), i, propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack, propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.createRef = function() {
        var refObject = {
            current: null
        };
        Object.seal(refObject);
        return refObject;
    };
    exports.forwardRef = function(render) {
        null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : "function" !== typeof render ? console.error("forwardRef requires a render function but was given %s.", null === render ? "null" : typeof render) : 0 !== render.length && 2 !== render.length && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", 1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
        null != render && null != render.defaultProps && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
        var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: render
        }, ownName;
        Object.defineProperty(elementType, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name;
                render.name || render.displayName || (Object.defineProperty(render, "name", {
                    value: name
                }), render.displayName = name);
            }
        });
        return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
        return {
            $$typeof: REACT_LAZY_TYPE,
            _payload: {
                _status: -1,
                _result: ctor
            },
            _init: lazyInitializer
        };
    };
    exports.memo = function(type, compare) {
        null == type && console.error("memo: The first argument must be a component. Instead received: %s", null === type ? "null" : typeof type);
        compare = {
            $$typeof: REACT_MEMO_TYPE,
            type: type,
            compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name;
                type.name || type.displayName || (Object.defineProperty(type, "name", {
                    value: name
                }), type.displayName = name);
            }
        });
        return compare;
    };
    exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        currentTransition._updatedFibers = new Set();
        try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
            reportGlobalError(error);
        } finally{
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), ReactSharedInternals.T = prevTransition;
        }
    };
    exports.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function(usable) {
        return resolveDispatcher().use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
        var dispatcher = resolveDispatcher();
        Context.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
        return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, createDeps, update) {
        null == create && console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?");
        var dispatcher = resolveDispatcher();
        if ("function" === typeof update) throw Error("useEffect CRUD overload is not enabled in this build of React.");
        return dispatcher.useEffect(create, createDeps);
    };
    exports.useId = function() {
        return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function(ref, create, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
        null == create && console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?");
        return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
        null == create && console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?");
        return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
        return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init) {
        return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    };
    exports.useTransition = function() {
        return resolveDispatcher().useTransition();
    };
    exports.version = "19.1.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}}),
"[project]/node_modules/react/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/react/cjs/react.development.js [client] (ecmascript)");
}
}}),
"[project]/node_modules/react/cjs/react-jsx-runtime.development.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        "react-stack-bottom-frame": function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = function(type, config, maybeKey, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, !1, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.jsxs = function(type, config, maybeKey, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, !0, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}}),
"[project]/node_modules/react/jsx-runtime.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/react/cjs/react-jsx-runtime.development.js [client] (ecmascript)");
}
}}),
"[project]/node_modules/react/cjs/react-jsx-dev-runtime.development.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        "react-stack-bottom-frame": function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}}),
"[project]/node_modules/react/jsx-dev-runtime.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/react/cjs/react-jsx-dev-runtime.development.js [client] (ecmascript)");
}
}}),
"[project]/node_modules/scheduler/cjs/scheduler.development.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function performWorkUntilDeadline() {
        needsPaint = !1;
        if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = !0;
            try {
                a: {
                    isHostCallbackScheduled = !1;
                    isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                    isPerformingWork = !0;
                    var previousPriorityLevel = currentPriorityLevel;
                    try {
                        b: {
                            advanceTimers(currentTime);
                            for(currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());){
                                var callback = currentTask.callback;
                                if ("function" === typeof callback) {
                                    currentTask.callback = null;
                                    currentPriorityLevel = currentTask.priorityLevel;
                                    var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                                    currentTime = exports.unstable_now();
                                    if ("function" === typeof continuationCallback) {
                                        currentTask.callback = continuationCallback;
                                        advanceTimers(currentTime);
                                        hasMoreWork = !0;
                                        break b;
                                    }
                                    currentTask === peek(taskQueue) && pop(taskQueue);
                                    advanceTimers(currentTime);
                                } else pop(taskQueue);
                                currentTask = peek(taskQueue);
                            }
                            if (null !== currentTask) hasMoreWork = !0;
                            else {
                                var firstTimer = peek(timerQueue);
                                null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                                hasMoreWork = !1;
                            }
                        }
                        break a;
                    } finally{
                        currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
                    }
                    hasMoreWork = void 0;
                }
            } finally{
                hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1;
            }
        }
    }
    function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for(; 0 < index;){
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
        }
    }
    function peek(heap) {
        return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
            heap[0] = last;
            a: for(var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;){
                var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
                if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
                else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;
                else break a;
            }
        }
        return first;
    }
    function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
        for(var timer = peek(timerQueue); null !== timer;){
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
        }
    }
    function handleTimeout(currentTime) {
        isHostTimeoutScheduled = !1;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = !0, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
        else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    function shouldYieldToHost() {
        return needsPaint ? !0 : exports.unstable_now() - startTime < frameInterval ? !1 : !0;
    }
    function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
        }, ms);
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports.unstable_now = function() {
            return localPerformance.now();
        };
    } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
            return localDate.now() - initialTime;
        };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1, needsPaint = !1, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = !1, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    if ("function" === typeof localSetImmediate) var schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
    };
    else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
        };
    } else schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
    };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
        task.callback = null;
    };
    exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
    };
    exports.unstable_next = function(eventHandler) {
        switch(currentPriorityLevel){
            case 1:
            case 2:
            case 3:
                var priorityLevel = 3;
                break;
            default:
                priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    };
    exports.unstable_requestPaint = function() {
        needsPaint = !0;
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch(priorityLevel){
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch(priorityLevel){
            case 1:
                var timeout = -1;
                break;
            case 2:
                timeout = 250;
                break;
            case 5:
                timeout = 1073741823;
                break;
            case 4:
                timeout = 1e4;
                break;
            default:
                timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
            id: taskIdCounter++,
            callback: callback,
            priorityLevel: priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
                return callback.apply(this, arguments);
            } finally{
                currentPriorityLevel = previousPriorityLevel;
            }
        };
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}}),
"[project]/node_modules/scheduler/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/scheduler/cjs/scheduler.development.js [client] (ecmascript)");
}
}}),
"[project]/node_modules/@wagmi/core/dist/esm/actions/getAccount.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/** https://wagmi.sh/core/api/actions/getAccount */ __turbopack_context__.s({
    "getAccount": (()=>getAccount)
});
function getAccount(config) {
    const uid = config.state.current;
    const connection = config.state.connections.get(uid);
    const addresses = connection?.accounts;
    const address = addresses?.[0];
    const chain = config.chains.find((chain)=>chain.id === connection?.chainId);
    const status = config.state.status;
    switch(status){
        case 'connected':
            return {
                address: address,
                addresses: addresses,
                chain,
                chainId: connection?.chainId,
                connector: connection?.connector,
                isConnected: true,
                isConnecting: false,
                isDisconnected: false,
                isReconnecting: false,
                status
            };
        case 'reconnecting':
            return {
                address,
                addresses,
                chain,
                chainId: connection?.chainId,
                connector: connection?.connector,
                isConnected: !!address,
                isConnecting: false,
                isDisconnected: false,
                isReconnecting: true,
                status
            };
        case 'connecting':
            return {
                address,
                addresses,
                chain,
                chainId: connection?.chainId,
                connector: connection?.connector,
                isConnected: false,
                isConnecting: true,
                isDisconnected: false,
                isReconnecting: false,
                status
            };
        case 'disconnected':
            return {
                address: undefined,
                addresses: undefined,
                chain: undefined,
                chainId: undefined,
                connector: undefined,
                isConnected: false,
                isConnecting: false,
                isDisconnected: true,
                isReconnecting: false,
                status
            };
    }
} //# sourceMappingURL=getAccount.js.map
}}),
"[project]/node_modules/@wagmi/core/dist/esm/utils/deepEqual.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/** Forked from https://github.com/epoberezkin/fast-deep-equal */ __turbopack_context__.s({
    "deepEqual": (()=>deepEqual)
});
function deepEqual(a, b) {
    if (a === b) return true;
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        if (a.constructor !== b.constructor) return false;
        let length;
        let i;
        if (Array.isArray(a) && Array.isArray(b)) {
            length = a.length;
            if (length !== b.length) return false;
            for(i = length; i-- !== 0;)if (!deepEqual(a[i], b[i])) return false;
            return true;
        }
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        const keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            const key = keys[i];
            if (key && !deepEqual(a[key], b[key])) return false;
        }
        return true;
    }
    // true if both NaN, false otherwise
    // biome-ignore lint/suspicious/noSelfCompare: <explanation>
    return a !== a && b !== b;
} //# sourceMappingURL=deepEqual.js.map
}}),
"[project]/node_modules/@wagmi/core/dist/esm/actions/watchAccount.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "watchAccount": (()=>watchAccount)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$utils$2f$deepEqual$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/utils/deepEqual.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/actions/getAccount.js [client] (ecmascript)");
;
;
function watchAccount(config, parameters) {
    const { onChange } = parameters;
    return config.subscribe(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAccount"])(config), onChange, {
        equalityFn (a, b) {
            const { connector: aConnector, ...aRest } = a;
            const { connector: bConnector, ...bRest } = b;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$utils$2f$deepEqual$2e$js__$5b$client$5d$__$28$ecmascript$29$__["deepEqual"])(aRest, bRest) && // check connector separately
            aConnector?.id === bConnector?.id && aConnector?.uid === bConnector?.uid;
        }
    });
} //# sourceMappingURL=watchAccount.js.map
}}),
"[project]/node_modules/@wagmi/core/dist/esm/actions/reconnect.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "reconnect": (()=>reconnect)
});
let isReconnecting = false;
async function reconnect(config, parameters = {}) {
    // If already reconnecting, do nothing
    if (isReconnecting) return [];
    isReconnecting = true;
    config.setState((x)=>({
            ...x,
            status: x.current ? 'reconnecting' : 'connecting'
        }));
    const connectors = [];
    if (parameters.connectors?.length) {
        for (const connector_ of parameters.connectors){
            let connector;
            // "Register" connector if not already created
            if (typeof connector_ === 'function') connector = config._internal.connectors.setup(connector_);
            else connector = connector_;
            connectors.push(connector);
        }
    } else connectors.push(...config.connectors);
    // Try recently-used connectors first
    let recentConnectorId;
    try {
        recentConnectorId = await config.storage?.getItem('recentConnectorId');
    } catch  {}
    const scores = {};
    for (const [, connection] of config.state.connections){
        scores[connection.connector.id] = 1;
    }
    if (recentConnectorId) scores[recentConnectorId] = 0;
    const sorted = Object.keys(scores).length > 0 ? [
        ...connectors
    ].sort((a, b)=>(scores[a.id] ?? 10) - (scores[b.id] ?? 10)) : connectors;
    // Iterate through each connector and try to connect
    let connected = false;
    const connections = [];
    const providers = [];
    for (const connector of sorted){
        const provider = await connector.getProvider().catch(()=>undefined);
        if (!provider) continue;
        // If we already have an instance of this connector's provider,
        // then we have already checked it (ie. injected connectors can
        // share the same `window.ethereum` instance, so we don't want to
        // connect to it again).
        if (providers.some((x)=>x === provider)) continue;
        const isAuthorized = await connector.isAuthorized();
        if (!isAuthorized) continue;
        const data = await connector.connect({
            isReconnecting: true
        }).catch(()=>null);
        if (!data) continue;
        connector.emitter.off('connect', config._internal.events.connect);
        connector.emitter.on('change', config._internal.events.change);
        connector.emitter.on('disconnect', config._internal.events.disconnect);
        config.setState((x)=>{
            const connections = new Map(connected ? x.connections : new Map()).set(connector.uid, {
                accounts: data.accounts,
                chainId: data.chainId,
                connector
            });
            return {
                ...x,
                current: connected ? x.current : connector.uid,
                connections
            };
        });
        connections.push({
            accounts: data.accounts,
            chainId: data.chainId,
            connector
        });
        providers.push(provider);
        connected = true;
    }
    // Prevent overwriting connected status from race condition
    if (config.state.status === 'reconnecting' || config.state.status === 'connecting') {
        // If connecting didn't succeed, set to disconnected
        if (!connected) config.setState((x)=>({
                ...x,
                connections: new Map(),
                current: null,
                status: 'disconnected'
            }));
        else config.setState((x)=>({
                ...x,
                status: 'connected'
            }));
    }
    isReconnecting = false;
    return connections;
} //# sourceMappingURL=reconnect.js.map
}}),
"[project]/node_modules/@wagmi/core/dist/esm/hydrate.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "hydrate": (()=>hydrate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$actions$2f$reconnect$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/actions/reconnect.js [client] (ecmascript)");
;
function hydrate(config, parameters) {
    const { initialState, reconnectOnMount } = parameters;
    if (initialState && !config._internal.store.persist.hasHydrated()) config.setState({
        ...initialState,
        chainId: config.chains.some((x)=>x.id === initialState.chainId) ? initialState.chainId : config.chains[0].id,
        connections: reconnectOnMount ? initialState.connections : new Map(),
        status: reconnectOnMount ? 'reconnecting' : 'disconnected'
    });
    return {
        async onMount () {
            if (config._internal.ssr) {
                await config._internal.store.persist.rehydrate();
                if (config._internal.mipd) {
                    config._internal.connectors.setState((connectors)=>{
                        const rdnsSet = new Set();
                        for (const connector of connectors ?? []){
                            if (connector.rdns) {
                                const rdnsValues = Array.isArray(connector.rdns) ? connector.rdns : [
                                    connector.rdns
                                ];
                                for (const rdns of rdnsValues){
                                    rdnsSet.add(rdns);
                                }
                            }
                        }
                        const mipdConnectors = [];
                        const providers = config._internal.mipd?.getProviders() ?? [];
                        for (const provider of providers){
                            if (rdnsSet.has(provider.info.rdns)) continue;
                            const connectorFn = config._internal.connectors.providerDetailToConnector(provider);
                            const connector = config._internal.connectors.setup(connectorFn);
                            mipdConnectors.push(connector);
                        }
                        return [
                            ...connectors,
                            ...mipdConnectors
                        ];
                    });
                }
            }
            if (reconnectOnMount) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$actions$2f$reconnect$2e$js__$5b$client$5d$__$28$ecmascript$29$__["reconnect"])(config);
            else if (config.storage) // Reset connections that may have been hydrated from storage.
            config.setState((x)=>({
                    ...x,
                    connections: new Map()
                }));
        }
    };
} //# sourceMappingURL=hydrate.js.map
}}),
"[project]/node_modules/@wagmi/core/dist/esm/version.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "version": (()=>version)
});
const version = '2.16.7'; //# sourceMappingURL=version.js.map
}}),
"[project]/node_modules/@wagmi/core/dist/esm/utils/getVersion.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getVersion": (()=>getVersion)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/version.js [client] (ecmascript)");
;
const getVersion = ()=>`@wagmi/core@${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["version"]}`; //# sourceMappingURL=getVersion.js.map
}}),
"[project]/node_modules/@wagmi/core/dist/esm/errors/base.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BaseError": (()=>BaseError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$utils$2f$getVersion$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/utils/getVersion.js [client] (ecmascript)");
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BaseError_instances, _BaseError_walk;
;
class BaseError extends Error {
    get docsBaseUrl() {
        return 'https://wagmi.sh/core';
    }
    get version() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$utils$2f$getVersion$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getVersion"])();
    }
    constructor(shortMessage, options = {}){
        super();
        _BaseError_instances.add(this);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'WagmiCoreError'
        });
        const details = options.cause instanceof BaseError ? options.cause.details : options.cause?.message ? options.cause.message : options.details;
        const docsPath = options.cause instanceof BaseError ? options.cause.docsPath || options.docsPath : options.docsPath;
        this.message = [
            shortMessage || 'An error occurred.',
            '',
            ...options.metaMessages ? [
                ...options.metaMessages,
                ''
            ] : [],
            ...docsPath ? [
                `Docs: ${this.docsBaseUrl}${docsPath}.html${options.docsSlug ? `#${options.docsSlug}` : ''}`
            ] : [],
            ...details ? [
                `Details: ${details}`
            ] : [],
            `Version: ${this.version}`
        ].join('\n');
        if (options.cause) this.cause = options.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = options.metaMessages;
        this.shortMessage = shortMessage;
    }
    walk(fn) {
        return __classPrivateFieldGet(this, _BaseError_instances, "m", _BaseError_walk).call(this, this, fn);
    }
}
_BaseError_instances = new WeakSet(), _BaseError_walk = function _BaseError_walk(err, fn) {
    if (fn?.(err)) return err;
    if (err.cause) return __classPrivateFieldGet(this, _BaseError_instances, "m", _BaseError_walk).call(this, err.cause, fn);
    return err;
}; //# sourceMappingURL=base.js.map
}}),
"[project]/node_modules/wagmi/dist/esm/hydrate.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Hydrate": (()=>Hydrate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$hydrate$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/hydrate.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
'use client';
;
;
function Hydrate(parameters) {
    const { children, config, initialState, reconnectOnMount = true } = parameters;
    const { onMount } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$hydrate$2e$js__$5b$client$5d$__$28$ecmascript$29$__["hydrate"])(config, {
        initialState,
        reconnectOnMount
    });
    // Hydrate for non-SSR
    if (!config._internal.ssr) onMount();
    // Hydrate for SSR
    const active = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(true);
    // biome-ignore lint/correctness/useExhaustiveDependencies: `queryKey` not required
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Hydrate.useEffect": ()=>{
            if (!active.current) return;
            if (!config._internal.ssr) return;
            onMount();
            return ({
                "Hydrate.useEffect": ()=>{
                    active.current = false;
                }
            })["Hydrate.useEffect"];
        }
    }["Hydrate.useEffect"], []);
    return children;
} //# sourceMappingURL=hydrate.js.map
}}),
"[project]/node_modules/wagmi/dist/esm/context.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "WagmiContext": (()=>WagmiContext),
    "WagmiProvider": (()=>WagmiProvider)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$hydrate$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/dist/esm/hydrate.js [client] (ecmascript)");
'use client';
;
;
const WagmiContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createContext"])(undefined);
function WagmiProvider(parameters) {
    const { children, config } = parameters;
    const props = {
        value: config
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$hydrate$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Hydrate"], parameters, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createElement"])(WagmiContext.Provider, props, children));
} //# sourceMappingURL=context.js.map
}}),
"[project]/node_modules/wagmi/dist/esm/version.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "version": (()=>version)
});
const version = '2.14.16'; //# sourceMappingURL=version.js.map
}}),
"[project]/node_modules/wagmi/dist/esm/utils/getVersion.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getVersion": (()=>getVersion)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/dist/esm/version.js [client] (ecmascript)");
;
const getVersion = ()=>`wagmi@${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$version$2e$js__$5b$client$5d$__$28$ecmascript$29$__["version"]}`; //# sourceMappingURL=getVersion.js.map
}}),
"[project]/node_modules/wagmi/dist/esm/errors/base.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BaseError": (()=>BaseError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$base$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/errors/base.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$utils$2f$getVersion$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/dist/esm/utils/getVersion.js [client] (ecmascript)");
;
;
class BaseError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$base$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor(){
        super(...arguments);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'WagmiError'
        });
    }
    get docsBaseUrl() {
        return 'https://wagmi.sh/react';
    }
    get version() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$utils$2f$getVersion$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getVersion"])();
    }
} //# sourceMappingURL=base.js.map
}}),
"[project]/node_modules/wagmi/dist/esm/errors/context.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "WagmiProviderNotFoundError": (()=>WagmiProviderNotFoundError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$errors$2f$base$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/dist/esm/errors/base.js [client] (ecmascript)");
;
class WagmiProviderNotFoundError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$errors$2f$base$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor(){
        super('`useConfig` must be used within `WagmiProvider`.', {
            docsPath: '/api/WagmiProvider'
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'WagmiProviderNotFoundError'
        });
    }
} //# sourceMappingURL=context.js.map
}}),
"[project]/node_modules/wagmi/dist/esm/hooks/useConfig.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useConfig": (()=>useConfig)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/dist/esm/context.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$errors$2f$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/dist/esm/errors/context.js [client] (ecmascript)");
'use client';
;
;
;
function useConfig(parameters = {}) {
    const config = parameters.config ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__["WagmiContext"]);
    if (!config) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$errors$2f$context$2e$js__$5b$client$5d$__$28$ecmascript$29$__["WagmiProviderNotFoundError"]();
    return config;
} //# sourceMappingURL=useConfig.js.map
}}),
"[project]/node_modules/wagmi/dist/esm/hooks/useSyncExternalStoreWithTracked.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useSyncExternalStoreWithTracked": (()=>useSyncExternalStoreWithTracked)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$utils$2f$deepEqual$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/utils/deepEqual.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-sync-external-store/shim/with-selector.js [client] (ecmascript)");
'use client';
;
;
;
const isPlainObject = (obj)=>typeof obj === 'object' && !Array.isArray(obj);
function useSyncExternalStoreWithTracked(subscribe, getSnapshot, getServerSnapshot = getSnapshot, isEqual = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$utils$2f$deepEqual$2e$js__$5b$client$5d$__$28$ecmascript$29$__["deepEqual"]) {
    const trackedKeys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])([]);
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useSyncExternalStoreWithSelector"])(subscribe, getSnapshot, getServerSnapshot, {
        "useSyncExternalStoreWithTracked.useSyncExternalStoreWithSelector[result]": (x)=>x
    }["useSyncExternalStoreWithTracked.useSyncExternalStoreWithSelector[result]"], {
        "useSyncExternalStoreWithTracked.useSyncExternalStoreWithSelector[result]": (a, b)=>{
            if (isPlainObject(a) && isPlainObject(b) && trackedKeys.current.length) {
                for (const key of trackedKeys.current){
                    const equal = isEqual(a[key], b[key]);
                    if (!equal) return false;
                }
                return true;
            }
            return isEqual(a, b);
        }
    }["useSyncExternalStoreWithTracked.useSyncExternalStoreWithSelector[result]"]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useSyncExternalStoreWithTracked.useMemo": ()=>{
            if (isPlainObject(result)) {
                const trackedResult = {
                    ...result
                };
                let properties = {};
                for (const [key, value] of Object.entries(trackedResult)){
                    properties = {
                        ...properties,
                        [key]: {
                            configurable: false,
                            enumerable: true,
                            get: ({
                                "useSyncExternalStoreWithTracked.useMemo": ()=>{
                                    if (!trackedKeys.current.includes(key)) {
                                        trackedKeys.current.push(key);
                                    }
                                    return value;
                                }
                            })["useSyncExternalStoreWithTracked.useMemo"]
                        }
                    };
                }
                Object.defineProperties(trackedResult, properties);
                return trackedResult;
            }
            return result;
        }
    }["useSyncExternalStoreWithTracked.useMemo"], [
        result
    ]);
} //# sourceMappingURL=useSyncExternalStoreWithTracked.js.map
}}),
"[project]/node_modules/wagmi/dist/esm/hooks/useAccount.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useAccount": (()=>useAccount)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/actions/getAccount.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$actions$2f$watchAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/actions/watchAccount.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$hooks$2f$useConfig$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/dist/esm/hooks/useConfig.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$hooks$2f$useSyncExternalStoreWithTracked$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/dist/esm/hooks/useSyncExternalStoreWithTracked.js [client] (ecmascript)");
'use client';
;
;
;
function useAccount(parameters = {}) {
    const config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$hooks$2f$useConfig$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useConfig"])(parameters);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$dist$2f$esm$2f$hooks$2f$useSyncExternalStoreWithTracked$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useSyncExternalStoreWithTracked"])({
        "useAccount.useSyncExternalStoreWithTracked": (onChange)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$actions$2f$watchAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["watchAccount"])(config, {
                onChange
            })
    }["useAccount.useSyncExternalStoreWithTracked"], {
        "useAccount.useSyncExternalStoreWithTracked": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAccount"])(config)
    }["useAccount.useSyncExternalStoreWithTracked"]);
} //# sourceMappingURL=useAccount.js.map
}}),
"[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
        }
        cachedValue = useState({
            inst: {
                value: value,
                getSnapshot: getSnapshot
            }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect({
            "useSyncExternalStore$2.useLayoutEffect": function() {
                inst.value = value;
                inst.getSnapshot = getSnapshot;
                checkIfSnapshotChanged(inst) && forceUpdate({
                    inst: inst
                });
            }
        }["useSyncExternalStore$2.useLayoutEffect"], [
            subscribe,
            value,
            getSnapshot
        ]);
        useEffect({
            "useSyncExternalStore$2.useEffect": function() {
                checkIfSnapshotChanged(inst) && forceUpdate({
                    inst: inst
                });
                return subscribe({
                    "useSyncExternalStore$2.useEffect": function() {
                        checkIfSnapshotChanged(inst) && forceUpdate({
                            inst: inst
                        });
                    }
                }["useSyncExternalStore$2.useEffect"]);
            }
        }["useSyncExternalStore$2.useEffect"], [
            subscribe
        ]);
        useDebugValue(value);
        return value;
    }
    function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
        } catch (error) {
            return !0;
        }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
    exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}}),
"[project]/node_modules/use-sync-external-store/shim/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [client] (ecmascript)");
}
}}),
"[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/react/index.js [client] (ecmascript)"), shim = __turbopack_context__.r("[project]/node_modules/use-sync-external-store/shim/index.js [client] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
    exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef(null);
        if (null === instRef.current) {
            var inst = {
                hasValue: !1,
                value: null
            };
            instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(function() {
            function memoizedSelector(nextSnapshot) {
                if (!hasMemo) {
                    hasMemo = !0;
                    memoizedSnapshot = nextSnapshot;
                    nextSnapshot = selector(nextSnapshot);
                    if (void 0 !== isEqual && inst.hasValue) {
                        var currentSelection = inst.value;
                        if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
                    }
                    return memoizedSelection = nextSnapshot;
                }
                currentSelection = memoizedSelection;
                if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
                var nextSelection = selector(nextSnapshot);
                if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
                memoizedSnapshot = nextSnapshot;
                return memoizedSelection = nextSelection;
            }
            var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
                function() {
                    return memoizedSelector(getSnapshot());
                },
                null === maybeGetServerSnapshot ? void 0 : function() {
                    return memoizedSelector(maybeGetServerSnapshot());
                }
            ];
        }, [
            getSnapshot,
            getServerSnapshot,
            selector,
            isEqual
        ]);
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect(function() {
            inst.hasValue = !0;
            inst.value = value;
        }, [
            value
        ]);
        useDebugValue(value);
        return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}}),
"[project]/node_modules/use-sync-external-store/shim/with-selector.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [client] (ecmascript)");
}
}}),
"[project]/node_modules/ipfs-core-utils/src/multibases.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec
 * @typedef {import('./types').LoadBaseFn} LoadBaseFn
 * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions
 */ /**
 * @type {LoadBaseFn}
 */ __turbopack_context__.s({
    "Multibases": (()=>Multibases)
});
const LOAD_BASE = (name)=>Promise.reject(new Error(`No base found for "${name}"`));
class Multibases {
    /**
   * @param {object} options
   * @param {LoadBaseFn} [options.loadBase]
   * @param {MultibaseCodec[]} options.bases
   */ constructor(options){
        // Object with current list of active resolvers
        /** @type {Record<string, MultibaseCodec>}} */ this._basesByName = {};
        // Object with current list of active resolvers
        /** @type {Record<string, MultibaseCodec>}} */ this._basesByPrefix = {};
        this._loadBase = options.loadBase || LOAD_BASE;
        // Enable all supplied codecs
        for (const base of options.bases){
            this.addBase(base);
        }
    }
    /**
   * Add support for a multibase codec
   *
   * @param {MultibaseCodec} base
   */ addBase(base) {
        if (this._basesByName[base.name] || this._basesByPrefix[base.prefix]) {
            throw new Error(`Codec already exists for codec "${base.name}"`);
        }
        this._basesByName[base.name] = base;
        this._basesByPrefix[base.prefix] = base;
    }
    /**
   * Remove support for a multibase codec
   *
   * @param {MultibaseCodec} base
   */ removeBase(base) {
        delete this._basesByName[base.name];
        delete this._basesByPrefix[base.prefix];
    }
    /**
   * @param {string} nameOrPrefix
   */ async getBase(nameOrPrefix) {
        if (this._basesByName[nameOrPrefix]) {
            return this._basesByName[nameOrPrefix];
        }
        if (this._basesByPrefix[nameOrPrefix]) {
            return this._basesByPrefix[nameOrPrefix];
        }
        // If not supported, attempt to dynamically load this codec
        const base = await this._loadBase(nameOrPrefix);
        if (this._basesByName[base.name] == null && this._basesByPrefix[base.prefix] == null) {
            this.addBase(base);
        }
        return base;
    }
    listBases() {
        return Object.values(this._basesByName);
    }
}
}}),
"[project]/node_modules/ipfs-core-utils/src/multicodecs.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec
 * @typedef {import('./types').LoadCodecFn} LoadCodecFn
 * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions
 */ /**
 * @type {LoadCodecFn}
 */ __turbopack_context__.s({
    "Multicodecs": (()=>Multicodecs)
});
const LOAD_CODEC = (codeOrName)=>Promise.reject(new Error(`No codec found for "${codeOrName}"`));
class Multicodecs {
    /**
   * @param {object} options
   * @param {LoadCodecFn} [options.loadCodec]
   * @param {BlockCodec[]} options.codecs
   */ constructor(options){
        // Object with current list of active resolvers
        /** @type {Record<string, BlockCodec>}} */ this._codecsByName = {};
        // Object with current list of active resolvers
        /** @type {Record<number, BlockCodec>}} */ this._codecsByCode = {};
        this._loadCodec = options.loadCodec || LOAD_CODEC;
        // Enable all supplied codecs
        for (const codec of options.codecs){
            this.addCodec(codec);
        }
    }
    /**
   * Add support for a block codec
   *
   * @param {BlockCodec} codec
   */ addCodec(codec) {
        if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
            throw new Error(`Resolver already exists for codec "${codec.name}"`);
        }
        this._codecsByName[codec.name] = codec;
        this._codecsByCode[codec.code] = codec;
    }
    /**
   * Remove support for a block codec
   *
   * @param {BlockCodec} codec
   */ removeCodec(codec) {
        delete this._codecsByName[codec.name];
        delete this._codecsByCode[codec.code];
    }
    /**
   * @param {number | string} code
   */ async getCodec(code) {
        const table = typeof code === 'string' ? this._codecsByName : this._codecsByCode;
        if (table[code]) {
            return table[code];
        }
        // If not supported, attempt to dynamically load this codec
        const codec = await this._loadCodec(code);
        if (table[code] == null) {
            this.addCodec(codec);
        }
        return codec;
    }
    listCodecs() {
        return Object.values(this._codecsByName);
    }
}
}}),
"[project]/node_modules/ipfs-core-utils/src/multihashes.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher
 * @typedef {import('./types').LoadHasherFn} LoadHasherFn
 * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions
 */ /**
 * @type {LoadHasherFn}
 */ __turbopack_context__.s({
    "Multihashes": (()=>Multihashes)
});
const LOAD_HASHER = (codeOrName)=>Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
class Multihashes {
    /**
   * @param {object} options
   * @param {LoadHasherFn} [options.loadHasher]
   * @param {MultihashHasher[]} options.hashers
   */ constructor(options){
        // Object with current list of active hashers
        /** @type {Record<string, MultihashHasher>}} */ this._hashersByName = {};
        // Object with current list of active hashers
        /** @type {Record<number, MultihashHasher>}} */ this._hashersByCode = {};
        this._loadHasher = options.loadHasher || LOAD_HASHER;
        // Enable all supplied hashers
        for (const hasher of options.hashers){
            this.addHasher(hasher);
        }
    }
    /**
   * Add support for a multibase hasher
   *
   * @param {MultihashHasher} hasher
   */ addHasher(hasher) {
        if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
            throw new Error(`Resolver already exists for codec "${hasher.name}"`);
        }
        this._hashersByName[hasher.name] = hasher;
        this._hashersByCode[hasher.code] = hasher;
    }
    /**
   * Remove support for a multibase hasher
   *
   * @param {MultihashHasher} hasher
   */ removeHasher(hasher) {
        delete this._hashersByName[hasher.name];
        delete this._hashersByCode[hasher.code];
    }
    /**
   * @param {number | string} code
   */ async getHasher(code) {
        const table = typeof code === 'string' ? this._hashersByName : this._hashersByCode;
        if (table[code]) {
            return table[code];
        }
        // If not supported, attempt to dynamically load this hasher
        const hasher = await this._loadHasher(code);
        if (table[code] == null) {
            this.addHasher(hasher);
        }
        return hasher;
    }
    listHashers() {
        return Object.values(this._hashersByName);
    }
}
}}),
"[project]/node_modules/ipfs-core-utils/src/to-url-string.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "toUrlString": (()=>toUrlString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js [client] (ecmascript)");
;
;
function toUrlString(url) {
    try {
        // @ts-expect-error
        url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["multiaddrToUri"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["multiaddr"])(url));
    } catch (/** @type {any} */ err) {}
    url = url.toString();
    return url;
}
}}),
"[project]/node_modules/ipfs-core-utils/src/agent.browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = ()=>{};
}}),
"[project]/node_modules/ipfs-core-utils/src/files/utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @param {any} obj
 * @returns {obj is ArrayBufferView|ArrayBuffer}
 */ __turbopack_context__.s({
    "isBlob": (()=>isBlob),
    "isBytes": (()=>isBytes),
    "isFileObject": (()=>isFileObject),
    "isReadableStream": (()=>isReadableStream)
});
function isBytes(obj) {
    return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
    return obj.constructor && (obj.constructor.name === 'Blob' || obj.constructor.name === 'File') && typeof obj.stream === 'function';
}
function isFileObject(obj) {
    return typeof obj === 'object' && (obj.path || obj.content);
}
const isReadableStream = (value)=>value && typeof value.getReader === 'function';
}}),
"[project]/node_modules/ipfs-core-utils/src/files/normalise-content.browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "normaliseContent": (()=>normaliseContent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/err-code/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$peekable$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/it-peekable/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$browser$2d$readablestream$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/browser-readablestream-to-it/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$all$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/it-all/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-core-utils/src/files/utils.js [client] (ecmascript)");
;
;
;
;
;
async function normaliseContent(input) {
    // Bytes
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBytes"])(input)) {
        return new Blob([
            input
        ]);
    }
    // String
    if (typeof input === 'string' || input instanceof String) {
        return new Blob([
            input.toString()
        ]);
    }
    // Blob | File
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(input)) {
        return input;
    }
    // Browser stream
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(input)) {
        input = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$browser$2d$readablestream$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(input);
    }
    // (Async)Iterator<?>
    if (Symbol.iterator in input || Symbol.asyncIterator in input) {
        /** @type {any} peekable */ const peekable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$peekable$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(input);
        /** @type {any} value **/ const { value, done } = await peekable.peek();
        if (done) {
            // make sure empty iterators result in empty files
            return itToBlob(peekable);
        }
        peekable.push(value);
        // (Async)Iterable<Number>
        if (Number.isInteger(value)) {
            return new Blob([
                Uint8Array.from(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$all$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(peekable))
            ]);
        }
        // (Async)Iterable<Bytes|String>
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBytes"])(value) || typeof value === 'string' || value instanceof String) {
            return itToBlob(peekable);
        }
    }
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT');
}
/**
 * @param {AsyncIterable<BlobPart>|Iterable<BlobPart>} stream
 */ async function itToBlob(stream) {
    const parts = [];
    for await (const chunk of stream){
        parts.push(chunk);
    }
    return new Blob(parts);
}
}}),
"[project]/node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "normaliseCandidateMultiple": (()=>normaliseCandidateMultiple)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/err-code/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$browser$2d$readablestream$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/browser-readablestream-to-it/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$peekable$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/it-peekable/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$map$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/it-map/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-core-utils/src/files/utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$unixfs$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-unixfs/src/index.js [client] (ecmascript)");
;
;
;
;
;
;
async function* normaliseCandidateMultiple(input, normaliseContent) {
    // String
    // Uint8Array|ArrayBuffer|TypedArray
    // Blob|File
    // fs.ReadStream
    // @ts-expect-error _readableState is a property of a node fs.ReadStream
    if (typeof input === 'string' || input instanceof String || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBytes"])(input) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(input) || input._readableState) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT');
    }
    // Browser ReadableStream
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(input)) {
        input = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$browser$2d$readablestream$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(input);
    }
    // Iterable<?>
    if (Symbol.iterator in input || Symbol.asyncIterator in input) {
        const peekable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$peekable$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(input);
        const { value, done } = await peekable.peek();
        if (done) {
            // make sure empty iterators result in empty files
            yield* [];
            return;
        }
        peekable.push(value);
        // (Async)Iterable<Number>
        // (Async)Iterable<Bytes>
        if (Number.isInteger(value)) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT');
        }
        // (Async)Iterable<fs.ReadStream>
        // @ts-expect-error private field
        if (value._readableState) {
            // @ts-expect-error Node fs.ReadStreams have a `.path` property so we need to pass it as the content
            yield* (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$map$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(peekable, (/** @type {ImportCandidate} */ value)=>toFileObject({
                    content: value
                }, normaliseContent));
            return;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBytes"])(value)) {
            // @ts-expect-error peekable is still an iterable of ImportCandidates
            yield toFileObject({
                content: peekable
            }, normaliseContent);
            return;
        }
        // (Async)Iterable<(Async)Iterable<?>>
        // (Async)Iterable<ReadableStream<?>>
        // ReadableStream<(Async)Iterable<?>>
        // ReadableStream<ReadableStream<?>>
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isFileObject"])(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(value) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(value)) {
            yield* (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$map$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(peekable, (/** @type {ImportCandidate} */ value)=>toFileObject(value, normaliseContent));
            return;
        }
    }
    // { path, content: ? }
    // Note: Detected _after_ (Async)Iterable<?> because Node.js fs.ReadStreams have a
    // `path` property that passes this check.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isFileObject"])(input)) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT');
    }
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');
}
/**
 * @param {ImportCandidate} input
 * @param {(content:ToContent) => Promise<AsyncIterable<Uint8Array>>} normaliseContent
 */ async function toFileObject(input, normaliseContent) {
    // @ts-expect-error - Those properties don't exist on most input types
    const { path, mode, mtime, content } = input;
    /** @type {ImporterImportCandidate} */ const file = {
        path: path || '',
        mode: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$unixfs$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMode"])(mode),
        mtime: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$unixfs$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMtime"])(mtime)
    };
    if (content) {
        file.content = await normaliseContent(content);
    } else if (!path) {
        // @ts-expect-error - input still can be different ToContent
        file.content = await normaliseContent(input);
    }
    return file;
}
}}),
"[project]/node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "normaliseInput": (()=>normaliseInput)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$normalise$2d$content$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-core-utils/src/files/normalise-content.browser.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$normalise$2d$candidate$2d$multiple$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js [client] (ecmascript)");
;
;
function normaliseInput(input) {
    // @ts-expect-error browser normaliseContent returns a Blob not an AsyncIterable<Uint8Array>
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$normalise$2d$candidate$2d$multiple$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normaliseCandidateMultiple"])(input, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$normalise$2d$content$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normaliseContent"], true);
}
}}),
"[project]/node_modules/ipfs-core-utils/src/mode-to-string.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @param {number | string | undefined} mode
 */ __turbopack_context__.s({
    "modeToString": (()=>modeToString)
});
function modeToString(mode) {
    if (mode == null) {
        return undefined;
    }
    if (typeof mode === 'string') {
        return mode;
    }
    return mode.toString(8).padStart(4, '0');
}
}}),
"[project]/node_modules/ipfs-core-utils/src/multipart-request.browser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Import browser version otherwise electron-renderer will end up with node
// version and fail.
__turbopack_context__.s({
    "multipartRequest": (()=>multipartRequest)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$normalise$2d$input$2d$multiple$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$mode$2d$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-core-utils/src/mode-to-string.js [client] (ecmascript)");
;
;
async function multipartRequest(source, abortController, headers = {}) {
    const parts = [];
    const formData = new FormData();
    let index = 0;
    let total = 0;
    for await (const { content, path, mode, mtime } of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$normalise$2d$input$2d$multiple$2e$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normaliseInput"])(source)){
        let fileSuffix = '';
        const type = content ? 'file' : 'dir';
        if (index > 0) {
            fileSuffix = `-${index}`;
        }
        let fieldName = type + fileSuffix;
        const qs = [];
        if (mode !== null && mode !== undefined) {
            qs.push(`mode=${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$mode$2d$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["modeToString"])(mode)}`);
        }
        if (mtime != null) {
            const { secs, nsecs } = mtime;
            qs.push(`mtime=${secs}`);
            if (nsecs != null) {
                qs.push(`mtime-nsecs=${nsecs}`);
            }
        }
        if (qs.length) {
            fieldName = `${fieldName}?${qs.join('&')}`;
        }
        if (content) {
            formData.set(fieldName, content, path != null ? encodeURIComponent(path) : undefined);
            const end = total + content.size;
            parts.push({
                name: path,
                start: total,
                end
            });
            total = end;
        } else if (path != null) {
            formData.set(fieldName, new File([
                ''
            ], encodeURIComponent(path), {
                type: 'application/x-directory'
            }));
        } else {
            throw new Error('path or content or both must be set');
        }
        index++;
    }
    return {
        total,
        parts,
        headers,
        body: formData
    };
}
}}),
"[project]/node_modules/ipfs-core-utils/src/pins/normalise-input.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "normaliseInput": (()=>normaliseInput)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/err-code/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/cid.js [client] (ecmascript) <locals>");
;
;
/**
 * @typedef {object} Pinnable
 * @property {string | InstanceType<typeof window.String> | CID} [path]
 * @property {CID} [cid]
 * @property {boolean} [recursive]
 * @property {any} [metadata]
 *
 * @typedef {CID|string|InstanceType<typeof window.String>|Pinnable} ToPin
 * @typedef {ToPin|Iterable<ToPin>|AsyncIterable<ToPin>} Source
 *
 * @typedef {object} Pin
 * @property {string|CID} path
 * @property {boolean} recursive
 * @property {any} [metadata]
 */ /**
 * @param {any} thing
 * @returns {thing is IterableIterator<any> & Iterator<any>}
 */ function isIterable(thing) {
    return Symbol.iterator in thing;
}
/**
 * @param {any} thing
 * @returns {thing is AsyncIterableIterator<any> & AsyncIterator<any>}
 */ function isAsyncIterable(thing) {
    return Symbol.asyncIterator in thing;
}
/**
 * @param {any} thing
 * @returns {thing is CID}
 */ function isCID(thing) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(thing) != null;
}
async function* normaliseInput(input) {
    // must give us something
    if (input === null || input === undefined) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT');
    }
    // CID
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(input);
    if (cid) {
        yield toPin({
            cid
        });
        return;
    }
    if (input instanceof String || typeof input === 'string') {
        yield toPin({
            path: input
        });
        return;
    }
    // { cid: CID recursive, metadata }
    // @ts-expect-error - it still could be iterable or async iterable
    if (input.cid != null || input.path != null) {
        // @ts-expect-error
        return yield toPin(input);
    }
    // Iterable<?>
    if (isIterable(input)) {
        const iterator = input[Symbol.iterator]();
        const first = iterator.next();
        if (first.done) {
            return iterator;
        }
        // Iterable<CID>
        if (isCID(first.value)) {
            yield toPin({
                cid: first.value
            });
            for (const cid of iterator){
                yield toPin({
                    cid
                });
            }
            return;
        }
        // Iterable<String>
        if (first.value instanceof String || typeof first.value === 'string') {
            yield toPin({
                path: first.value
            });
            for (const path of iterator){
                yield toPin({
                    path
                });
            }
            return;
        }
        // Iterable<Pinnable>
        if (first.value.cid != null || first.value.path != null) {
            yield toPin(first.value);
            for (const obj of iterator){
                yield toPin(obj);
            }
            return;
        }
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');
    }
    // AsyncIterable<?>
    if (isAsyncIterable(input)) {
        const iterator = input[Symbol.asyncIterator]();
        const first = await iterator.next();
        if (first.done) return iterator;
        // AsyncIterable<CID>
        if (isCID(first.value)) {
            yield toPin({
                cid: first.value
            });
            for await (const cid of iterator){
                yield toPin({
                    cid
                });
            }
            return;
        }
        // AsyncIterable<String>
        if (first.value instanceof String || typeof first.value === 'string') {
            yield toPin({
                path: first.value
            });
            for await (const path of iterator){
                yield toPin({
                    path
                });
            }
            return;
        }
        // AsyncIterable<{ cid: CID|String recursive, metadata }>
        if (first.value.cid != null || first.value.path != null) {
            yield toPin(first.value);
            for await (const obj of iterator){
                yield toPin(obj);
            }
            return;
        }
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');
    }
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');
}
/**
 * @param {Pinnable} input
 */ function toPin(input) {
    const path = input.cid || `${input.path}`;
    if (!path) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Unexpected input: Please path either a CID or an IPFS path'), 'ERR_UNEXPECTED_INPUT');
    }
    /** @type {Pin} */ const pin = {
        path,
        recursive: input.recursive !== false
    };
    if (input.metadata != null) {
        pin.metadata = input.metadata;
    }
    return pin;
}
}}),
"[project]/node_modules/ipfs-core-utils/src/files/normalise-content.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "normaliseContent": (()=>normaliseContent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/err-code/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/from-string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$browser$2d$readablestream$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/browser-readablestream-to-it/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$blob$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/blob-to-it/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$peekable$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/it-peekable/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$all$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/it-all/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$map$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/it-map/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-core-utils/src/files/utils.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
/**
 * @template T
 * @param {T} thing
 */ async function* toAsyncIterable(thing) {
    yield thing;
}
async function normaliseContent(input) {
    // Bytes | String
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBytes"])(input)) {
        return toAsyncIterable(toBytes(input));
    }
    if (typeof input === 'string' || input instanceof String) {
        return toAsyncIterable(toBytes(input.toString()));
    }
    // Blob
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(input)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$blob$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(input);
    }
    // Browser stream
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(input)) {
        input = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$browser$2d$readablestream$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(input);
    }
    // (Async)Iterator<?>
    if (Symbol.iterator in input || Symbol.asyncIterator in input) {
        /** @type {any} peekable */ const peekable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$peekable$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(input);
        /** @type {any} value */ const { value, done } = await peekable.peek();
        if (done) {
            // make sure empty iterators result in empty files
            return toAsyncIterable(new Uint8Array(0));
        }
        peekable.push(value);
        // (Async)Iterable<Number>
        if (Number.isInteger(value)) {
            return toAsyncIterable(Uint8Array.from(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$all$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(peekable)));
        }
        // (Async)Iterable<Bytes|String>
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBytes"])(value) || typeof value === 'string' || value instanceof String) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$map$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(peekable, toBytes);
        }
    }
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT');
}
/**
 * @param {ArrayBuffer | ArrayBufferView | string | InstanceType<typeof window.String> | number[]} chunk
 */ function toBytes(chunk) {
    if (chunk instanceof Uint8Array) {
        return chunk;
    }
    if (ArrayBuffer.isView(chunk)) {
        return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    }
    if (chunk instanceof ArrayBuffer) {
        return new Uint8Array(chunk);
    }
    if (Array.isArray(chunk)) {
        return Uint8Array.from(chunk);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromString"])(chunk.toString());
}
}}),
"[project]/node_modules/ipfs-core-utils/src/files/normalise-candidate-single.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "normaliseCandidateSingle": (()=>normaliseCandidateSingle)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/err-code/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$browser$2d$readablestream$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/browser-readablestream-to-it/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$peekable$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/it-peekable/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-core-utils/src/files/utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$unixfs$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-unixfs/src/index.js [client] (ecmascript)");
;
;
;
;
;
async function* normaliseCandidateSingle(input, normaliseContent) {
    if (input === null || input === undefined) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT');
    }
    // String
    if (typeof input === 'string' || input instanceof String) {
        yield toFileObject(input.toString(), normaliseContent);
        return;
    }
    // Uint8Array|ArrayBuffer|TypedArray
    // Blob|File
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBytes"])(input) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBlob"])(input)) {
        yield toFileObject(input, normaliseContent);
        return;
    }
    // Browser ReadableStream
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isReadableStream"])(input)) {
        input = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$browser$2d$readablestream$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(input);
    }
    // Iterable<?>
    if (Symbol.iterator in input || Symbol.asyncIterator in input) {
        const peekable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$it$2d$peekable$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(input);
        /** @type {any} value **/ const { value, done } = await peekable.peek();
        if (done) {
            // make sure empty iterators result in empty files
            yield {
                content: []
            };
            return;
        }
        peekable.push(value);
        // (Async)Iterable<Number>
        // (Async)Iterable<Bytes>
        // (Async)Iterable<String>
        if (Number.isInteger(value) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isBytes"])(value) || typeof value === 'string' || value instanceof String) {
            yield toFileObject(peekable, normaliseContent);
            return;
        }
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead'), 'ERR_UNEXPECTED_INPUT');
    }
    // { path, content: ? }
    // Note: Detected _after_ (Async)Iterable<?> because Node.js fs.ReadStreams have a
    // `path` property that passes this check.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isFileObject"])(input)) {
        yield toFileObject(input, normaliseContent);
        return;
    }
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), 'ERR_UNEXPECTED_INPUT');
}
/**
 * @param {ImportCandidate} input
 * @param {(content:ToContent) => Promise<AsyncIterable<Uint8Array>>} normaliseContent
 */ async function toFileObject(input, normaliseContent) {
    // @ts-expect-error - Those properties don't exist on most input types
    const { path, mode, mtime, content } = input;
    /** @type {ImporterImportCandidate} */ const file = {
        path: path || '',
        mode: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$unixfs$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMode"])(mode),
        mtime: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$unixfs$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseMtime"])(mtime)
    };
    if (content) {
        file.content = await normaliseContent(content);
    } else if (!path) {
        // @ts-expect-error - input still can be different ToContent
        file.content = await normaliseContent(input);
    }
    return file;
}
}}),
"[project]/node_modules/ipfs-core-utils/src/files/normalise-input-single.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "normaliseInput": (()=>normaliseInput)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$normalise$2d$content$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-core-utils/src/files/normalise-content.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$normalise$2d$candidate$2d$single$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-core-utils/src/files/normalise-candidate-single.js [client] (ecmascript)");
;
;
function normaliseInput(input) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$normalise$2d$candidate$2d$single$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normaliseCandidateSingle"])(input, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$core$2d$utils$2f$src$2f$files$2f$normalise$2d$content$2e$js__$5b$client$5d$__$28$ecmascript$29$__["normaliseContent"]);
}
}}),
"[project]/node_modules/@ipld/dag-pb/src/pb-decode.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "decodeNode": (()=>decodeNode)
});
const textDecoder = new TextDecoder();
/**
 * @typedef {import('./interface.js').RawPBLink} RawPBLink
 */ /**
 * @typedef {import('./interface.js').RawPBNode} RawPBNode
 */ /**
 * @param {Uint8Array} bytes
 * @param {number} offset
 * @returns {[number, number]}
 */ function decodeVarint(bytes, offset) {
    let v = 0;
    for(let shift = 0;; shift += 7){
        /* c8 ignore next 3 */ if (shift >= 64) {
            throw new Error('protobuf: varint overflow');
        }
        /* c8 ignore next 3 */ if (offset >= bytes.length) {
            throw new Error('protobuf: unexpected end of data');
        }
        const b = bytes[offset++];
        v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * 2 ** shift;
        if (b < 0x80) {
            break;
        }
    }
    return [
        v,
        offset
    ];
}
/**
 * @param {Uint8Array} bytes
 * @param {number} offset
 * @returns {[Uint8Array, number]}
 */ function decodeBytes(bytes, offset) {
    let byteLen;
    [byteLen, offset] = decodeVarint(bytes, offset);
    const postOffset = offset + byteLen;
    /* c8 ignore next 3 */ if (byteLen < 0 || postOffset < 0) {
        throw new Error('protobuf: invalid length');
    }
    /* c8 ignore next 3 */ if (postOffset > bytes.length) {
        throw new Error('protobuf: unexpected end of data');
    }
    return [
        bytes.subarray(offset, postOffset),
        postOffset
    ];
}
/**
 * @param {Uint8Array} bytes
 * @param {number} index
 * @returns {[number, number, number]}
 */ function decodeKey(bytes, index) {
    let wire;
    [wire, index] = decodeVarint(bytes, index);
    // [wireType, fieldNum, newIndex]
    return [
        wire & 0x7,
        wire >> 3,
        index
    ];
}
/**
 * @param {Uint8Array} bytes
 * @returns {RawPBLink}
 */ function decodeLink(bytes) {
    /** @type {RawPBLink} */ const link = {};
    const l = bytes.length;
    let index = 0;
    while(index < l){
        let wireType, fieldNum;
        [wireType, fieldNum, index] = decodeKey(bytes, index);
        if (fieldNum === 1) {
            if (link.Hash) {
                throw new Error('protobuf: (PBLink) duplicate Hash section');
            }
            if (wireType !== 2) {
                throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
            }
            if (link.Name !== undefined) {
                throw new Error('protobuf: (PBLink) invalid order, found Name before Hash');
            }
            if (link.Tsize !== undefined) {
                throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash');
            }
            [link.Hash, index] = decodeBytes(bytes, index);
        } else if (fieldNum === 2) {
            if (link.Name !== undefined) {
                throw new Error('protobuf: (PBLink) duplicate Name section');
            }
            if (wireType !== 2) {
                throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
            }
            if (link.Tsize !== undefined) {
                throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name');
            }
            let byts;
            [byts, index] = decodeBytes(bytes, index);
            link.Name = textDecoder.decode(byts);
        } else if (fieldNum === 3) {
            if (link.Tsize !== undefined) {
                throw new Error('protobuf: (PBLink) duplicate Tsize section');
            }
            if (wireType !== 0) {
                throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
            }
            [link.Tsize, index] = decodeVarint(bytes, index);
        } else {
            throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
        }
    }
    /* c8 ignore next 3 */ if (index > l) {
        throw new Error('protobuf: (PBLink) unexpected end of data');
    }
    return link;
}
function decodeNode(bytes) {
    const l = bytes.length;
    let index = 0;
    /** @type {RawPBLink[]|void} */ let links = undefined // eslint-disable-line no-undef-init
    ;
    let linksBeforeData = false;
    /** @type {Uint8Array|void} */ let data = undefined // eslint-disable-line no-undef-init
    ;
    while(index < l){
        let wireType, fieldNum;
        [wireType, fieldNum, index] = decodeKey(bytes, index);
        if (wireType !== 2) {
            throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
        }
        if (fieldNum === 1) {
            if (data) {
                throw new Error('protobuf: (PBNode) duplicate Data section');
            }
            [data, index] = decodeBytes(bytes, index);
            if (links) {
                linksBeforeData = true;
            }
        } else if (fieldNum === 2) {
            if (linksBeforeData) {
                throw new Error('protobuf: (PBNode) duplicate Links section');
            } else if (!links) {
                links = [];
            }
            let byts;
            [byts, index] = decodeBytes(bytes, index);
            links.push(decodeLink(byts));
        } else {
            throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
        }
    }
    /* c8 ignore next 3 */ if (index > l) {
        throw new Error('protobuf: (PBNode) unexpected end of data');
    }
    /** @type {RawPBNode} */ const node = {};
    if (data) {
        node.Data = data;
    }
    node.Links = links || [];
    return node;
}
}}),
"[project]/node_modules/@ipld/dag-pb/src/pb-encode.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "encodeNode": (()=>encodeNode)
});
const textEncoder = new TextEncoder();
const maxInt32 = 2 ** 32;
const maxUInt32 = 2 ** 31;
/**
 * @typedef {import('./interface.js').RawPBLink} RawPBLink
 */ /**
 * @typedef {import('./interface.js').RawPBNode} RawPBNode
 */ // the encoders work backward from the end of the bytes array
/**
 * encodeLink() is passed a slice of the parent byte array that ends where this
 * link needs to end, so it packs to the right-most part of the passed `bytes`
 *
 * @param {RawPBLink} link
 * @param {Uint8Array} bytes
 * @returns {number}
 */ function encodeLink(link, bytes) {
    let i = bytes.length;
    if (typeof link.Tsize === 'number') {
        if (link.Tsize < 0) {
            throw new Error('Tsize cannot be negative');
        }
        if (!Number.isSafeInteger(link.Tsize)) {
            throw new Error('Tsize too large for encoding');
        }
        i = encodeVarint(bytes, i, link.Tsize) - 1;
        bytes[i] = 0x18;
    }
    if (typeof link.Name === 'string') {
        const nameBytes = textEncoder.encode(link.Name);
        i -= nameBytes.length;
        bytes.set(nameBytes, i);
        i = encodeVarint(bytes, i, nameBytes.length) - 1;
        bytes[i] = 0x12;
    }
    if (link.Hash) {
        i -= link.Hash.length;
        bytes.set(link.Hash, i);
        i = encodeVarint(bytes, i, link.Hash.length) - 1;
        bytes[i] = 0xa;
    }
    return bytes.length - i;
}
function encodeNode(node) {
    const size = sizeNode(node);
    const bytes = new Uint8Array(size);
    let i = size;
    if (node.Data) {
        i -= node.Data.length;
        bytes.set(node.Data, i);
        i = encodeVarint(bytes, i, node.Data.length) - 1;
        bytes[i] = 0xa;
    }
    if (node.Links) {
        for(let index = node.Links.length - 1; index >= 0; index--){
            const size = encodeLink(node.Links[index], bytes.subarray(0, i));
            i -= size;
            i = encodeVarint(bytes, i, size) - 1;
            bytes[i] = 0x12;
        }
    }
    return bytes;
}
/**
 * work out exactly how many bytes this link takes up
 *
 * @param {RawPBLink} link
 * @returns
 */ function sizeLink(link) {
    let n = 0;
    if (link.Hash) {
        const l = link.Hash.length;
        n += 1 + l + sov(l);
    }
    if (typeof link.Name === 'string') {
        const l = textEncoder.encode(link.Name).length;
        n += 1 + l + sov(l);
    }
    if (typeof link.Tsize === 'number') {
        n += 1 + sov(link.Tsize);
    }
    return n;
}
/**
 * Work out exactly how many bytes this node takes up
 *
 * @param {RawPBNode} node
 * @returns {number}
 */ function sizeNode(node) {
    let n = 0;
    if (node.Data) {
        const l = node.Data.length;
        n += 1 + l + sov(l);
    }
    if (node.Links) {
        for (const link of node.Links){
            const l = sizeLink(link);
            n += 1 + l + sov(l);
        }
    }
    return n;
}
/**
 * @param {Uint8Array} bytes
 * @param {number} offset
 * @param {number} v
 * @returns {number}
 */ function encodeVarint(bytes, offset, v) {
    offset -= sov(v);
    const base = offset;
    while(v >= maxUInt32){
        bytes[offset++] = v & 0x7f | 0x80;
        v /= 128;
    }
    while(v >= 128){
        bytes[offset++] = v & 0x7f | 0x80;
        v >>>= 7;
    }
    bytes[offset] = v;
    return base;
}
/**
 * size of varint
 *
 * @param {number} x
 * @returns {number}
 */ function sov(x) {
    if (x % 2 === 0) {
        x++;
    }
    return Math.floor((len64(x) + 6) / 7);
}
/**
 * golang math/bits, how many bits does it take to represent this integer?
 *
 * @param {number} x
 * @returns {number}
 */ function len64(x) {
    let n = 0;
    if (x >= maxInt32) {
        x = Math.floor(x / maxInt32);
        n = 32;
    }
    if (x >= 1 << 16) {
        x >>>= 16;
        n += 16;
    }
    if (x >= 1 << 8) {
        x >>>= 8;
        n += 8;
    }
    return n + len8tab[x];
}
// golang math/bits
const len8tab = [
    0,
    1,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8
];
}}),
"[project]/node_modules/@ipld/dag-pb/src/util.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLink": (()=>createLink),
    "createNode": (()=>createNode),
    "prepare": (()=>prepare),
    "toByteView": (()=>toByteView),
    "validate": (()=>validate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <locals>");
;
/**
 * @typedef {import('./interface.js').PBLink} PBLink
 * @typedef {import('./interface.js').PBNode} PBNode
 */ /**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView
 */ /**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView
 */ const pbNodeProperties = [
    'Data',
    'Links'
];
const pbLinkProperties = [
    'Hash',
    'Name',
    'Tsize'
];
const textEncoder = new TextEncoder();
/**
 * @param {PBLink} a
 * @param {PBLink} b
 * @returns {number}
 */ function linkComparator(a, b) {
    if (a === b) {
        return 0;
    }
    const abuf = a.Name ? textEncoder.encode(a.Name) : [];
    const bbuf = b.Name ? textEncoder.encode(b.Name) : [];
    let x = abuf.length;
    let y = bbuf.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (abuf[i] !== bbuf[i]) {
            x = abuf[i];
            y = bbuf[i];
            break;
        }
    }
    return x < y ? -1 : y < x ? 1 : 0;
}
/**
 * @param {any} node
 * @param {string[]} properties
 * @returns {boolean}
 */ function hasOnlyProperties(node, properties) {
    return !Object.keys(node).some((p)=>!properties.includes(p));
}
/**
 * Converts a CID, or a PBLink-like object to a PBLink
 *
 * @param {any} link
 * @returns {PBLink}
 */ function asLink(link) {
    if (typeof link.asCID === 'object') {
        const Hash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(link);
        if (!Hash) {
            throw new TypeError('Invalid DAG-PB form');
        }
        return {
            Hash
        };
    }
    if (typeof link !== 'object' || Array.isArray(link)) {
        throw new TypeError('Invalid DAG-PB form');
    }
    const pbl = {};
    if (link.Hash) {
        let cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(link.Hash);
        try {
            if (!cid) {
                if (typeof link.Hash === 'string') {
                    cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(link.Hash);
                } else if (link.Hash instanceof Uint8Array) {
                    cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(link.Hash);
                }
            }
        } catch (/** @type {any} */ e) {
            throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
        }
        if (cid) {
            pbl.Hash = cid;
        }
    }
    if (!pbl.Hash) {
        throw new TypeError('Invalid DAG-PB form');
    }
    if (typeof link.Name === 'string') {
        pbl.Name = link.Name;
    }
    if (typeof link.Tsize === 'number') {
        pbl.Tsize = link.Tsize;
    }
    return pbl;
}
function prepare(node) {
    if (node instanceof Uint8Array || typeof node === 'string') {
        node = {
            Data: node
        };
    }
    if (typeof node !== 'object' || Array.isArray(node)) {
        throw new TypeError('Invalid DAG-PB form');
    }
    /** @type {PBNode} */ const pbn = {};
    if (node.Data !== undefined) {
        if (typeof node.Data === 'string') {
            pbn.Data = textEncoder.encode(node.Data);
        } else if (node.Data instanceof Uint8Array) {
            pbn.Data = node.Data;
        } else {
            throw new TypeError('Invalid DAG-PB form');
        }
    }
    if (node.Links !== undefined) {
        if (Array.isArray(node.Links)) {
            pbn.Links = node.Links.map(asLink);
            pbn.Links.sort(linkComparator);
        } else {
            throw new TypeError('Invalid DAG-PB form');
        }
    } else {
        pbn.Links = [];
    }
    return pbn;
}
function validate(node) {
    /*
  type PBLink struct {
    Hash optional Link
    Name optional String
    Tsize optional Int
  }

  type PBNode struct {
    Links [PBLink]
    Data optional Bytes
  }
  */ // @ts-ignore private property for TS
    if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || node['/'] && node['/'] === node.bytes) {
        throw new TypeError('Invalid DAG-PB form');
    }
    if (!hasOnlyProperties(node, pbNodeProperties)) {
        throw new TypeError('Invalid DAG-PB form (extraneous properties)');
    }
    if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {
        throw new TypeError('Invalid DAG-PB form (Data must be bytes)');
    }
    if (!Array.isArray(node.Links)) {
        throw new TypeError('Invalid DAG-PB form (Links must be a list)');
    }
    for(let i = 0; i < node.Links.length; i++){
        const link = node.Links[i];
        // @ts-ignore private property for TS
        if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || link['/'] && link['/'] === link.bytes) {
            throw new TypeError('Invalid DAG-PB form (bad link)');
        }
        if (!hasOnlyProperties(link, pbLinkProperties)) {
            throw new TypeError('Invalid DAG-PB form (extraneous properties on link)');
        }
        if (link.Hash === undefined) {
            throw new TypeError('Invalid DAG-PB form (link must have a Hash)');
        }
        // @ts-ignore private property for TS
        if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {
            throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)');
        }
        if (link.Name !== undefined && typeof link.Name !== 'string') {
            throw new TypeError('Invalid DAG-PB form (link Name must be a string)');
        }
        if (link.Tsize !== undefined) {
            if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {
                throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)');
            }
            if (link.Tsize < 0) {
                throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)');
            }
        }
        if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
            throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)');
        }
    }
}
function createNode(data, links = []) {
    return prepare({
        Data: data,
        Links: links
    });
}
function createLink(name, size, cid) {
    return asLink({
        Hash: cid,
        Name: name,
        Tsize: size
    });
}
function toByteView(buf) {
    if (buf instanceof ArrayBuffer) {
        return new Uint8Array(buf, 0, buf.byteLength);
    }
    return buf;
}
}}),
"[project]/node_modules/@ipld/dag-pb/src/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "code": (()=>code),
    "decode": (()=>decode),
    "encode": (()=>encode),
    "name": (()=>name)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$decode$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/pb-decode.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$encode$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/pb-encode.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/util.js [client] (ecmascript)");
;
;
;
;
const name = 'dag-pb';
const code = 0x70;
function encode(node) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["validate"])(node);
    const pbn = {};
    if (node.Links) {
        pbn.Links = node.Links.map((l)=>{
            const link = {};
            if (l.Hash) {
                link.Hash = l.Hash.bytes // cid -> bytes
                ;
            }
            if (l.Name !== undefined) {
                link.Name = l.Name;
            }
            if (l.Tsize !== undefined) {
                link.Tsize = l.Tsize;
            }
            return link;
        });
    }
    if (node.Data) {
        pbn.Data = node.Data;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$encode$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeNode"])(pbn);
}
function decode(bytes) {
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toByteView"])(bytes);
    const pbn = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$decode$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decodeNode"])(buf);
    const node = {};
    if (pbn.Data) {
        node.Data = pbn.Data;
    }
    if (pbn.Links) {
        node.Links = pbn.Links.map((l)=>{
            const link = {};
            try {
                link.Hash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(l.Hash);
            } catch (e) {}
            if (!link.Hash) {
                throw new Error('Invalid Hash field found in link, expected CID');
            }
            if (l.Name !== undefined) {
                link.Name = l.Name;
            }
            if (l.Tsize !== undefined) {
                link.Tsize = l.Tsize;
            }
            return link;
        });
    }
    return node;
}
;
}}),
"[project]/node_modules/@ipld/dag-pb/src/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$decode$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/pb-decode.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$encode$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/pb-encode.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/util.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/index.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@ipld/dag-pb/src/index.js [client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "code": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"]),
    "createLink": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createLink"]),
    "createNode": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createNode"]),
    "decode": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"]),
    "encode": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"]),
    "name": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["name"]),
    "prepare": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["prepare"]),
    "validate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["validate"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/util.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/index.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@ipld/dag-pb/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "code": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["code"]),
    "createLink": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createLink"]),
    "createNode": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createNode"]),
    "decode": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["decode"]),
    "encode": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["encode"]),
    "name": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["name"]),
    "prepare": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["prepare"]),
    "validate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["validate"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/index.js [client] (ecmascript) <exports>");
}}),
"[project]/node_modules/@ipld/dag-cbor/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "code": (()=>code),
    "decode": (()=>decode),
    "decodeOptions": (()=>decodeOptions),
    "encode": (()=>encode),
    "encodeOptions": (()=>encodeOptions),
    "name": (()=>name),
    "toByteView": (()=>toByteView)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$cborg$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/cborg.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$encode$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/encode.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$decode$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/decode.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/token.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <locals>");
;
;
// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692
const CID_CBOR_TAG = 42;
function toByteView(buf) {
    if (buf instanceof ArrayBuffer) {
        return new Uint8Array(buf, 0, buf.byteLength);
    }
    return buf;
}
/**
 * cidEncoder will receive all Objects during encode, it needs to filter out
 * anything that's not a CID and return `null` for that so it's encoded as
 * normal.
 *
 * @param {any} obj
 * @returns {cborg.Token[]|null}
 */ function cidEncoder(obj) {
    if (obj.asCID !== obj && obj['/'] !== obj.bytes) {
        return null // any other kind of object
        ;
    }
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(obj);
    /* c8 ignore next 4 */ // very unlikely case, and it'll probably throw a recursion error in cborg
    if (!cid) {
        return null;
    }
    const bytes = new Uint8Array(cid.bytes.byteLength + 1);
    bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons
    ;
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].tag, CID_CBOR_TAG),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].bytes, bytes)
    ];
}
// eslint-disable-next-line jsdoc/require-returns-check
/**
 * Intercept all `undefined` values from an object walk and reject the entire
 * object if we find one.
 *
 * @returns {null}
 */ function undefinedEncoder() {
    throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');
}
/**
 * Intercept all `number` values from an object walk and reject the entire
 * object if we find something that doesn't fit the IPLD data model (NaN &
 * Infinity).
 *
 * @param {number} num
 * @returns {null}
 */ function numberEncoder(num) {
    if (Number.isNaN(num)) {
        throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');
    }
    if (num === Infinity || num === -Infinity) {
        throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');
    }
    return null;
}
const _encodeOptions = {
    float64: true,
    typeEncoders: {
        Object: cidEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
    }
};
const encodeOptions = {
    ..._encodeOptions,
    typeEncoders: {
        ..._encodeOptions.typeEncoders
    }
};
/**
 * @param {Uint8Array} bytes
 * @returns {CID}
 */ function cidDecoder(bytes) {
    if (bytes[0] !== 0) {
        throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(bytes.subarray(1)) // ignore leading 0x00
    ;
}
const _decodeOptions = {
    allowIndefinite: false,
    coerceUndefinedToNull: true,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */ tags: []
};
_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
const decodeOptions = {
    ..._decodeOptions,
    tags: _decodeOptions.tags.slice()
};
const name = 'dag-cbor';
const code = 0x71;
const encode = (node)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$encode$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encode"])(node, _encodeOptions);
const decode = (data)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$decode$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(toByteView(data), _decodeOptions);
}}),
"[project]/node_modules/@ipld/dag-json/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint max-depth: ["error", 7] */ __turbopack_context__.s({
    "code": (()=>code),
    "decode": (()=>decode),
    "encode": (()=>encode),
    "format": (()=>format),
    "name": (()=>name),
    "parse": (()=>parse),
    "stringify": (()=>format)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$cborg$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/cborg.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/token.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$json$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/json.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/decode.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$encode$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/encode.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/bases/base64.js [client] (ecmascript)");
;
;
;
;
/**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView
 */ /**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView
 */ /**
 * @template T
 * @typedef {import('multiformats').ToString<T>} ToString
 */ /**
 * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer
 */ /**
 * @template T
 * @param {ByteView<T> | ArrayBufferView<T>} buf
 * @returns {ByteView<T>}
 */ function toByteView(buf) {
    if (buf instanceof ArrayBuffer) {
        return new Uint8Array(buf, 0, buf.byteLength);
    }
    return buf;
}
/**
 * cidEncoder will receive all Objects during encode, it needs to filter out
 * anything that's not a CID and return `null` for that so it's encoded as
 * normal. Encoding a CID means replacing it with a `{"/":"<CidString>}`
 * object as per the DAG-JSON spec.
 *
 * @param {any} obj
 * @returns {Token[]|null}
 */ function cidEncoder(obj) {
    if (obj.asCID !== obj && obj['/'] !== obj.bytes) {
        return null // any other kind of object
        ;
    }
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(obj);
    /* c8 ignore next 4 */ // very unlikely case, and it'll probably throw a recursion error in cborg
    if (!cid) {
        return null;
    }
    const cidString = cid.toString();
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].string, '/', 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].string, cidString, cidString.length),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1)
    ];
}
/**
 * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it
 * needs to replace it with a `{"/":{"bytes":"Base64ByteString"}}` object as
 * per the DAG-JSON spec.
 *
 * @param {Uint8Array} bytes
 * @returns {Token[]|null}
 */ function bytesEncoder(bytes) {
    const bytesString = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base64"].encode(bytes).slice(1) // no mbase prefix
    ;
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].string, '/', 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].string, 'bytes', 5),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].string, bytesString, bytesString.length),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1)
    ];
}
/**
 * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so
 * that we access the underlying ArrayBuffer data
 *
 * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj
 * @returns {Token[]|null}
 */ function taBytesEncoder(obj) {
    return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
}
/**
 * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers
 *
 * @param {ArrayBuffer} ab
 * @returns {Token[]|null}
 */ function abBytesEncoder(ab) {
    return bytesEncoder(new Uint8Array(ab));
}
// eslint-disable-next-line jsdoc/require-returns-check
/**
 * Intercept all `undefined` values from an object walk and reject the entire
 * object if we find one.
 *
 * @returns {null}
 */ function undefinedEncoder() {
    throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');
}
/**
 * Intercept all `number` values from an object walk and reject the entire
 * object if we find something that doesn't fit the IPLD data model (NaN &
 * Infinity).
 *
 * @param {number} num
 * @returns {null}
 */ function numberEncoder(num) {
    if (Number.isNaN(num)) {
        throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');
    }
    if (num === Infinity || num === -Infinity) {
        throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');
    }
    return null // process with standard number encoder
    ;
}
const encodeOptions = {
    typeEncoders: {
        Object: cidEncoder,
        Buffer: bytesEncoder,
        Uint8Array: bytesEncoder,
        Int8Array: taBytesEncoder,
        Uint16Array: taBytesEncoder,
        Int16Array: taBytesEncoder,
        Uint32Array: taBytesEncoder,
        Int32Array: taBytesEncoder,
        Float32Array: taBytesEncoder,
        Float64Array: taBytesEncoder,
        Uint8ClampedArray: taBytesEncoder,
        BigInt64Array: taBytesEncoder,
        BigUint64Array: taBytesEncoder,
        DataView: taBytesEncoder,
        ArrayBuffer: abBytesEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
    }
};
/**
 * @implements {DecodeTokenizer}
 */ class DagJsonTokenizer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Tokenizer"] {
    /**
   * @param {Uint8Array} data
   * @param {object} [options]
   */ constructor(data, options){
        super(data, options);
        /** @type {Token[]} */ this.tokenBuffer = [];
    }
    /**
   * @returns {boolean}
   */ done() {
        return this.tokenBuffer.length === 0 && super.done();
    }
    /**
   * @returns {Token}
   */ _next() {
        if (this.tokenBuffer.length > 0) {
            // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406
            return this.tokenBuffer.pop();
        }
        return super.next();
    }
    /**
   * Implements rules outlined in https://github.com/ipld/specs/pull/356
   *
   * @returns {Token}
   */ next() {
        const token = this._next();
        if (token.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].map) {
            const keyToken = this._next();
            if (keyToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].string && keyToken.value === '/') {
                const valueToken = this._next();
                if (valueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].string) {
                    const breakToken = this._next() // swallow the end-of-map token
                    ;
                    if (breakToken.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].break) {
                        throw new Error('Invalid encoded CID form');
                    }
                    this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token
                    ;
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].tag, 42, 0);
                }
                if (valueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].map) {
                    const innerKeyToken = this._next();
                    if (innerKeyToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].string && innerKeyToken.value === 'bytes') {
                        const innerValueToken = this._next();
                        if (innerValueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].string) {
                            for(let i = 0; i < 2; i++){
                                const breakToken = this._next() // swallow two end-of-map tokens
                                ;
                                if (breakToken.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].break) {
                                    throw new Error('Invalid encoded Bytes form');
                                }
                            }
                            const bytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base64"].decode(`m${innerValueToken.value}`);
                            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Type"].bytes, bytes, innerValueToken.value.length);
                        }
                        this.tokenBuffer.push(innerValueToken) // bail
                        ;
                    }
                    this.tokenBuffer.push(innerKeyToken) // bail
                    ;
                }
                this.tokenBuffer.push(valueToken) // bail
                ;
            }
            this.tokenBuffer.push(keyToken) // bail
            ;
        }
        return token;
    }
}
const decodeOptions = {
    allowIndefinite: false,
    allowUndefined: false,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */ tags: []
};
// we're going to get TAG(42)STRING("bafy...") from the tokenizer so we only need
// to deal with the STRING("bafy...") at this point
decodeOptions.tags[42] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse;
const name = 'dag-json';
const code = 0x0129;
const encode = (node)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$encode$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encode"])(node, encodeOptions);
const decode = (data)=>{
    const buf = toByteView(data);
    // the tokenizer is stateful so we need a single instance of it
    const options = Object.assign(decodeOptions, {
        tokenizer: new DagJsonTokenizer(buf, decodeOptions)
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(buf, options);
};
const format = (node)=>utf8Decoder.decode(encode(node));
;
const utf8Decoder = new TextDecoder();
const parse = (data)=>decode(utf8Encoder.encode(data));
const utf8Encoder = new TextEncoder();
}}),
"[project]/node_modules/dag-jose/lib/utils.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "fromBase64url": (()=>fromBase64url),
    "toBase64url": (()=>toBase64url)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base64$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/bases/base64.js [client] (ecmascript)");
;
function toBase64url(b) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base64$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base64url"].encode(b).slice(1);
}
function fromBase64url(s) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base64$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base64url"].decode(`u${s}`);
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/dag-jose/lib/signing.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "decode": (()=>decode),
    "encode": (()=>encode),
    "fromSplit": (()=>fromSplit)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dag-jose/lib/utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/cid.js [client] (ecmascript) <locals>");
;
;
function fromSplit(split) {
    const [protectedHeader, payload, signature] = split;
    return {
        payload,
        signatures: [
            {
                protected: protectedHeader,
                signature
            }
        ],
        link: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBase64url"])(payload))
    };
}
function encodeSignature(signature) {
    const encoded = {
        signature: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBase64url"])(signature.signature)
    };
    if (signature.header) encoded.header = signature.header;
    if (signature.protected) encoded.protected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBase64url"])(signature.protected);
    return encoded;
}
function encode(jws) {
    const payload = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBase64url"])(jws.payload);
    try {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(payload);
    } catch (e) {
        throw new Error('Not a valid DagJWS');
    }
    return {
        payload,
        signatures: jws.signatures.map(encodeSignature)
    };
}
function decodeSignature(encoded) {
    const sign = {
        signature: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBase64url"])(encoded.signature)
    };
    if (encoded.header) sign.header = encoded.header;
    if (encoded.protected) sign.protected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBase64url"])(encoded.protected);
    return sign;
}
function decode(encoded) {
    const decoded = {
        payload: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBase64url"])(encoded.payload),
        signatures: encoded.signatures.map(decodeSignature)
    };
    decoded.link = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(new Uint8Array(encoded.payload));
    return decoded;
} //# sourceMappingURL=signing.js.map
}}),
"[project]/node_modules/dag-jose/lib/encryption.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "decode": (()=>decode),
    "encode": (()=>encode),
    "fromSplit": (()=>fromSplit)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dag-jose/lib/utils.js [client] (ecmascript)");
;
function fromSplit(split) {
    const [protectedHeader, encrypted_key, iv, ciphertext, tag] = split;
    const jwe = {
        ciphertext,
        iv,
        protected: protectedHeader,
        tag
    };
    if (encrypted_key) jwe.recipients = [
        {
            encrypted_key
        }
    ];
    return jwe;
}
function encodeRecipient(recipient) {
    const encRec = {};
    if (recipient.encrypted_key) encRec.encrypted_key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBase64url"])(recipient.encrypted_key);
    if (recipient.header) encRec.header = recipient.header;
    return encRec;
}
function encode(jwe) {
    const encJwe = {
        ciphertext: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBase64url"])(jwe.ciphertext),
        protected: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBase64url"])(jwe.protected),
        iv: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBase64url"])(jwe.iv),
        tag: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBase64url"])(jwe.tag)
    };
    if (jwe.aad) encJwe.aad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBase64url"])(jwe.aad);
    if (jwe.recipients) encJwe.recipients = jwe.recipients.map(encodeRecipient);
    if (jwe.unprotected) encJwe.unprotected = jwe.unprotected;
    return encJwe;
}
function decodeRecipient(encoded) {
    const recipient = {};
    if (encoded.encrypted_key) recipient.encrypted_key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBase64url"])(encoded.encrypted_key);
    if (encoded.header) recipient.header = encoded.header;
    return recipient;
}
function decode(encoded) {
    const jwe = {
        ciphertext: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBase64url"])(encoded.ciphertext),
        protected: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBase64url"])(encoded.protected),
        iv: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBase64url"])(encoded.iv),
        tag: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBase64url"])(encoded.tag)
    };
    if (encoded.aad) jwe.aad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBase64url"])(encoded.aad);
    if (encoded.recipients) jwe.recipients = encoded.recipients.map(decodeRecipient);
    if (encoded.unprotected) jwe.unprotected = encoded.unprotected;
    return jwe;
} //# sourceMappingURL=encryption.js.map
}}),
"[project]/node_modules/dag-jose/lib/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "code": (()=>code),
    "decode": (()=>decode),
    "encode": (()=>encode),
    "name": (()=>name),
    "toGeneral": (()=>toGeneral)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$signing$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dag-jose/lib/signing.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$encryption$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dag-jose/lib/encryption.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [client] (ecmascript)");
;
;
;
const name = 'dag-jose';
const code = 133;
function isDagJWS(jose) {
    return 'payload' in jose && typeof jose.payload === 'string' && 'signatures' in jose && Array.isArray(jose.signatures);
}
function isEncodedJWS(jose) {
    return 'payload' in jose && jose.payload instanceof Uint8Array && 'signatures' in jose && Array.isArray(jose.signatures);
}
function isEncodedJWE(jose) {
    return 'ciphertext' in jose && jose.ciphertext instanceof Uint8Array && 'iv' in jose && jose.iv instanceof Uint8Array && 'protected' in jose && jose.protected instanceof Uint8Array && 'tag' in jose && jose.tag instanceof Uint8Array;
}
function isDagJWE(jose) {
    return 'ciphertext' in jose && typeof jose.ciphertext === 'string' && 'iv' in jose && typeof jose.iv === 'string' && 'protected' in jose && typeof jose.protected === 'string' && 'tag' in jose && typeof jose.tag === 'string';
}
function toGeneral(jose) {
    if (typeof jose === 'string') {
        const split = jose.split('.');
        if (split.length === 3) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$signing$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromSplit"])(split);
        } else if (split.length === 5) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$encryption$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromSplit"])(split);
        }
        throw new Error('Not a valid JOSE string');
    }
    if (isDagJWS(jose) || isDagJWE(jose)) {
        return jose;
    }
    throw new Error('Not a valid unencoded JOSE object');
}
function encode(obj) {
    if (typeof obj === 'string') {
        obj = toGeneral(obj);
    }
    let encodedJose;
    if (isDagJWS(obj)) {
        encodedJose = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$signing$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encode"])(obj);
    } else if (isDagJWE(obj)) {
        encodedJose = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$encryption$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encode"])(obj);
    } else {
        throw new Error('Not a valid JOSE object');
    }
    return new Uint8Array((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encode"])(encodedJose));
}
function decode(data) {
    let encoded;
    try {
        encoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(data);
    } catch (e) {
        throw new Error('Not a valid DAG-JOSE object');
    }
    if (isEncodedJWS(encoded)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$signing$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(encoded);
    } else if (isEncodedJWE(encoded)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dag$2d$jose$2f$lib$2f$encryption$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(encoded);
    } else {
        throw new Error('Not a valid DAG-JOSE object');
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@chainsafe/is-ip/lib/parser.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable @typescript-eslint/no-unsafe-return */ __turbopack_context__.s({
    "Parser": (()=>Parser)
});
class Parser {
    index = 0;
    input = "";
    new(input) {
        this.index = 0;
        this.input = input;
        return this;
    }
    /** Run a parser, and restore the pre-parse state if it fails. */ readAtomically(fn) {
        const index = this.index;
        const result = fn();
        if (result === undefined) {
            this.index = index;
        }
        return result;
    }
    /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */ parseWith(fn) {
        const result = fn();
        if (this.index !== this.input.length) {
            return undefined;
        }
        return result;
    }
    /** Peek the next character from the input */ peekChar() {
        if (this.index >= this.input.length) {
            return undefined;
        }
        return this.input[this.index];
    }
    /** Read the next character from the input */ readChar() {
        if (this.index >= this.input.length) {
            return undefined;
        }
        return this.input[this.index++];
    }
    /** Read the next character from the input if it matches the target. */ readGivenChar(target) {
        return this.readAtomically(()=>{
            const char = this.readChar();
            if (char !== target) {
                return undefined;
            }
            return char;
        });
    }
    /**
     * Helper for reading separators in an indexed loop. Reads the separator
     * character iff index > 0, then runs the parser. When used in a loop,
     * the separator character will only be read on index > 0 (see
     * readIPv4Addr for an example)
     */ readSeparator(sep, index, inner) {
        return this.readAtomically(()=>{
            if (index > 0) {
                if (this.readGivenChar(sep) === undefined) {
                    return undefined;
                }
            }
            return inner();
        });
    }
    /**
     * Read a number off the front of the input in the given radix, stopping
     * at the first non-digit character or eof. Fails if the number has more
     * digits than max_digits or if there is no number.
     */ readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
        return this.readAtomically(()=>{
            let result = 0;
            let digitCount = 0;
            const leadingChar = this.peekChar();
            if (leadingChar === undefined) {
                return undefined;
            }
            const hasLeadingZero = leadingChar === "0";
            const maxValue = 2 ** (8 * maxBytes) - 1;
            // eslint-disable-next-line no-constant-condition
            while(true){
                const digit = this.readAtomically(()=>{
                    const char = this.readChar();
                    if (char === undefined) {
                        return undefined;
                    }
                    const num = Number.parseInt(char, radix);
                    if (Number.isNaN(num)) {
                        return undefined;
                    }
                    return num;
                });
                if (digit === undefined) {
                    break;
                }
                result *= radix;
                result += digit;
                if (result > maxValue) {
                    return undefined;
                }
                digitCount += 1;
                if (maxDigits !== undefined) {
                    if (digitCount > maxDigits) {
                        return undefined;
                    }
                }
            }
            if (digitCount === 0) {
                return undefined;
            } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
                return undefined;
            } else {
                return result;
            }
        });
    }
    /** Read an IPv4 address. */ readIPv4Addr() {
        return this.readAtomically(()=>{
            const out = new Uint8Array(4);
            for(let i = 0; i < out.length; i++){
                const ix = this.readSeparator(".", i, ()=>this.readNumber(10, 3, false, 1));
                if (ix === undefined) {
                    return undefined;
                }
                out[i] = ix;
            }
            return out;
        });
    }
    /** Read an IPv6 Address. */ readIPv6Addr() {
        /**
         * Read a chunk of an IPv6 address into `groups`. Returns the number
         * of groups read, along with a bool indicating if an embedded
         * trailing IPv4 address was read. Specifically, read a series of
         * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional
         * trailing embedded IPv4 address.
         */ const readGroups = (groups)=>{
            for(let i = 0; i < groups.length / 2; i++){
                const ix = i * 2;
                // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.
                if (i < groups.length - 3) {
                    const ipv4 = this.readSeparator(":", i, ()=>this.readIPv4Addr());
                    if (ipv4 !== undefined) {
                        groups[ix] = ipv4[0];
                        groups[ix + 1] = ipv4[1];
                        groups[ix + 2] = ipv4[2];
                        groups[ix + 3] = ipv4[3];
                        return [
                            ix + 4,
                            true
                        ];
                    }
                }
                const group = this.readSeparator(":", i, ()=>this.readNumber(16, 4, true, 2));
                if (group === undefined) {
                    return [
                        ix,
                        false
                    ];
                }
                groups[ix] = group >> 8;
                groups[ix + 1] = group & 255;
            }
            return [
                groups.length,
                false
            ];
        };
        return this.readAtomically(()=>{
            // Read the front part of the address; either the whole thing, or up to the first ::
            const head = new Uint8Array(16);
            const [headSize, headIp4] = readGroups(head);
            if (headSize === 16) {
                return head;
            }
            // IPv4 part is not allowed before `::`
            if (headIp4) {
                return undefined;
            }
            // Read `::` if previous code parsed less than 8 groups.
            // `::` indicates one or more groups of 16 bits of zeros.
            if (this.readGivenChar(":") === undefined) {
                return undefined;
            }
            if (this.readGivenChar(":") === undefined) {
                return undefined;
            }
            // Read the back part of the address. The :: must contain at least one
            // set of zeroes, so our max length is 7.
            const tail = new Uint8Array(14);
            const limit = 16 - (headSize + 2);
            const [tailSize] = readGroups(tail.subarray(0, limit));
            // Concat the head and tail of the IP address
            head.set(tail.subarray(0, tailSize), 16 - tailSize);
            return head;
        });
    }
    /** Read an IP Address, either IPv4 or IPv6. */ readIPAddr() {
        return this.readIPv4Addr() ?? this.readIPv6Addr();
    }
} //# sourceMappingURL=parser.js.map
}}),
"[project]/node_modules/@chainsafe/is-ip/lib/parse.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parseIP": (()=>parseIP),
    "parseIPv4": (()=>parseIPv4),
    "parseIPv4Mapped": (()=>parseIPv4Mapped),
    "parseIPv6": (()=>parseIPv6)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/is-ip/lib/parser.js [client] (ecmascript)");
;
// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address
const MAX_IPV6_LENGTH = 45;
const MAX_IPV4_LENGTH = 15;
const parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Parser"]();
function parseIPv4(input) {
    if (input.length > MAX_IPV4_LENGTH) {
        return undefined;
    }
    return parser.new(input).parseWith(()=>parser.readIPv4Addr());
}
function parseIPv4Mapped(input) {
    if (input.length > MAX_IPV4_LENGTH) {
        return undefined;
    }
    const ipv4 = parser.new(input).parseWith(()=>parser.readIPv4Addr());
    if (ipv4 === undefined) {
        return undefined;
    }
    return Uint8Array.from([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0xff,
        0xff,
        ipv4[0],
        ipv4[1],
        ipv4[2],
        ipv4[3]
    ]);
}
function parseIPv6(input) {
    // strip zone index if it is present
    if (input.includes("%")) {
        input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
        return undefined;
    }
    return parser.new(input).parseWith(()=>parser.readIPv6Addr());
}
function parseIP(input, mapIPv4ToIPv6 = false) {
    // strip zone index if it is present
    if (input.includes("%")) {
        input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
        return undefined;
    }
    const addr = parser.new(input).parseWith(()=>parser.readIPAddr());
    if (!addr) {
        return undefined;
    }
    if (mapIPv4ToIPv6 && addr.length === 4) {
        return Uint8Array.from([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0xff,
            0xff,
            addr[0],
            addr[1],
            addr[2],
            addr[3]
        ]);
    }
    return addr;
} //# sourceMappingURL=parse.js.map
}}),
"[project]/node_modules/@chainsafe/is-ip/lib/is-ip.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ipVersion": (()=>ipVersion),
    "isIP": (()=>isIP),
    "isIPv4": (()=>isIPv4),
    "isIPv6": (()=>isIPv6)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/is-ip/lib/parse.js [client] (ecmascript)");
;
function isIPv4(input) {
    return Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseIPv4"])(input));
}
function isIPv6(input) {
    return Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseIPv6"])(input));
}
function isIP(input) {
    return Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseIP"])(input));
}
function ipVersion(input) {
    if (isIPv4(input)) {
        return 4;
    } else if (isIPv6(input)) {
        return 6;
    } else {
        return undefined;
    }
} //# sourceMappingURL=is-ip.js.map
}}),
"[project]/node_modules/uint8arrays/dist/src/util/as-uint8array.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * To guarantee Uint8Array semantics, convert nodejs Buffers
 * into vanilla Uint8Arrays
 */ __turbopack_context__.s({
    "asUint8Array": (()=>asUint8Array)
});
function asUint8Array(buf) {
    if (globalThis.Buffer != null) {
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    return buf;
} //# sourceMappingURL=as-uint8array.js.map
}}),
"[project]/node_modules/uint8arrays/dist/src/alloc.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "alloc": (()=>alloc),
    "allocUnsafe": (()=>allocUnsafe)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/util/as-uint8array.js [client] (ecmascript)");
;
function alloc(size = 0) {
    if (globalThis.Buffer?.alloc != null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$client$5d$__$28$ecmascript$29$__["asUint8Array"])(globalThis.Buffer.alloc(size));
    }
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    if (globalThis.Buffer?.allocUnsafe != null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$client$5d$__$28$ecmascript$29$__["asUint8Array"])(globalThis.Buffer.allocUnsafe(size));
    }
    return new Uint8Array(size);
} //# sourceMappingURL=alloc.js.map
}}),
"[project]/node_modules/uint8arrays/dist/src/util/bases.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$node_modules$2f$multiformats$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/node_modules/multiformats/src/basics.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$node_modules$2f$multiformats$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/node_modules/multiformats/src/basics.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/alloc.js [client] (ecmascript)");
;
;
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let string = 'a';
    for(let i = 0; i < buf.length; i++){
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$node_modules$2f$multiformats$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"].base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$node_modules$2f$multiformats$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]
};
const __TURBOPACK__default__export__ = BASES;
 //# sourceMappingURL=bases.js.map
}}),
"[project]/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "toString": (()=>toString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/util/bases.js [client] (ecmascript)");
;
function toString(array, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');
    }
    // strip multibase prefix
    return base.encoder.encode(array).substring(1);
} //# sourceMappingURL=to-string.js.map
}}),
"[project]/node_modules/uint8arrays/dist/src/from-string.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "fromString": (()=>fromString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/util/as-uint8array.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/util/bases.js [client] (ecmascript)");
;
;
function fromString(string, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$client$5d$__$28$ecmascript$29$__["asUint8Array"])(globalThis.Buffer.from(string, 'utf-8'));
    }
    // add multibase prefix
    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
} //# sourceMappingURL=from-string.js.map
}}),
"[project]/node_modules/uint8arrays/dist/src/concat.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "concat": (()=>concat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/alloc.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/util/as-uint8array.js [client] (ecmascript)");
;
;
function concat(arrays, length) {
    if (length == null) {
        length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    }
    const output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$client$5d$__$28$ecmascript$29$__["asUint8Array"])(output);
} //# sourceMappingURL=concat.js.map
}}),
"[project]/node_modules/uint8arrays/dist/src/equals.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Returns true if the two passed Uint8Arrays have the same content
 */ __turbopack_context__.s({
    "equals": (()=>equals)
});
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=equals.js.map
}}),
"[project]/node_modules/uint8-varint/node_modules/uint8arrays/dist/src/alloc.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */ __turbopack_context__.s({
    "alloc": (()=>alloc),
    "allocUnsafe": (()=>allocUnsafe)
});
function alloc(size = 0) {
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    return new Uint8Array(size);
} //# sourceMappingURL=alloc.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/alloc.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */ __turbopack_context__.s({
    "alloc": (()=>alloc),
    "allocUnsafe": (()=>allocUnsafe)
});
function alloc(size = 0) {
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    return new Uint8Array(size);
} //# sourceMappingURL=alloc.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/util/as-uint8array.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * To guarantee Uint8Array semantics, convert nodejs Buffers
 * into vanilla Uint8Arrays
 */ __turbopack_context__.s({
    "asUint8Array": (()=>asUint8Array)
});
function asUint8Array(buf) {
    return buf;
} //# sourceMappingURL=as-uint8array.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/concat.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "concat": (()=>concat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/alloc.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/util/as-uint8array.js [client] (ecmascript)");
;
;
function concat(arrays, length) {
    if (length == null) {
        length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    }
    const output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$client$5d$__$28$ecmascript$29$__["asUint8Array"])(output);
} //# sourceMappingURL=concat.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/util/bases.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/basics.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/basics.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/alloc.js [client] (ecmascript)");
;
;
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let string = 'a';
    for(let i = 0; i < buf.length; i++){
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"].base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]
};
const __TURBOPACK__default__export__ = BASES;
 //# sourceMappingURL=bases.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "toString": (()=>toString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/util/bases.js [client] (ecmascript)");
;
function toString(array, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // strip multibase prefix
    return base.encoder.encode(array).substring(1);
} //# sourceMappingURL=to-string.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/from-string.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "fromString": (()=>fromString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/util/bases.js [client] (ecmascript)");
;
function fromString(string, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // add multibase prefix
    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
} //# sourceMappingURL=from-string.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/equals.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Returns true if the two passed Uint8Arrays have the same content
 */ __turbopack_context__.s({
    "equals": (()=>equals)
});
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=equals.js.map
}}),
"[project]/node_modules/varint/encode.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = encode;
var MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode(num, out, offset) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode.bytes = 0;
        throw new RangeError('Could not encode varint');
    }
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 0xFF | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 0xFF | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
}
}}),
"[project]/node_modules/varint/decode.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = read;
var MSB = 0x80, REST = 0x7F;
function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l || shift > 49) {
            read.bytes = 0;
            throw new RangeError('Could not decode varint');
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB)
    read.bytes = counter - offset;
    return res;
}
}}),
"[project]/node_modules/varint/length.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
module.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
}}),
"[project]/node_modules/varint/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = {
    encode: __turbopack_context__.r("[project]/node_modules/varint/encode.js [client] (ecmascript)"),
    decode: __turbopack_context__.r("[project]/node_modules/varint/decode.js [client] (ecmascript)"),
    encodingLength: __turbopack_context__.r("[project]/node_modules/varint/length.js [client] (ecmascript)")
};
}}),
"[project]/node_modules/err-code/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/**
 * @typedef {{ [key: string]: any }} Extensions
 * @typedef {Error} Err
 * @property {string} message
 */ /**
 *
 * @param {Error} obj
 * @param {Extensions} props
 * @returns {Error & Extensions}
 */ function assign(obj, props) {
    for(const key in props){
        Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true
        });
    }
    return obj;
}
/**
 *
 * @param {any} err - An Error
 * @param {string|Extensions} code - A string code or props to set on the error
 * @param {Extensions} [props] - Props to set on the error
 * @returns {Error & Extensions}
 */ function createError(err, code, props) {
    if (!err || typeof err === 'string') {
        throw new TypeError('Please pass an Error to err-code');
    }
    if (!props) {
        props = {};
    }
    if (typeof code === 'object') {
        props = code;
        code = '';
    }
    if (code) {
        props.code = code;
    }
    try {
        return assign(err, props);
    } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {};
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        // @ts-ignore
        const output = assign(new ErrClass(), props);
        return output;
    }
}
module.exports = createError;
}}),
"[project]/node_modules/is-electron/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// https://github.com/electron/electron/issues/2288
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
function isElectron() {
    // Renderer process
    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
        return true;
    }
    // Main process
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].versions === 'object' && !!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].versions.electron) {
        return true;
    }
    // Detect the user agent when the `nodeIntegration` option is set to false
    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {
        return true;
    }
    return false;
}
module.exports = isElectron;
}}),
"[project]/node_modules/ipfs-utils/src/env.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use strict';
const isElectron = __turbopack_context__.r("[project]/node_modules/is-electron/index.js [client] (ecmascript)");
const IS_ENV_WITH_DOM = typeof window === 'object' && typeof document === 'object' && document.nodeType === 9;
// @ts-ignore
const IS_ELECTRON = isElectron();
const IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
const IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
const IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
const IS_NODE = ("TURBOPACK compile-time value", "function") === 'function' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].release !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].release.name === 'node' && !IS_ELECTRON;
// @ts-ignore - we either ignore worker scope or dom scope
const IS_WEBWORKER = typeof importScripts === 'function' && typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
const IS_TEST = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].env !== 'undefined' && ("TURBOPACK compile-time value", "development") === 'test';
const IS_REACT_NATIVE = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';
module.exports = {
    isTest: IS_TEST,
    isElectron: IS_ELECTRON,
    isElectronMain: IS_ELECTRON_MAIN,
    isElectronRenderer: IS_ELECTRON_RENDERER,
    isNode: IS_NODE,
    /**
   * Detects browser main thread  **NOT** web worker or service worker
   */ isBrowser: IS_BROWSER,
    isWebWorker: IS_WEBWORKER,
    isEnvWithDom: IS_ENV_WITH_DOM,
    isReactNative: IS_REACT_NATIVE
};
}}),
"[project]/node_modules/ipfs-utils/src/http/error.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
class TimeoutError extends Error {
    constructor(message = 'Request timed out'){
        super(message);
        this.name = 'TimeoutError';
    }
}
exports.TimeoutError = TimeoutError;
class AbortError extends Error {
    constructor(message = 'The operation was aborted.'){
        super(message);
        this.name = 'AbortError';
    }
}
exports.AbortError = AbortError;
class HTTPError extends Error {
    /**
   * @param {Response} response
   */ constructor(response){
        super(response.statusText);
        this.name = 'HTTPError';
        this.response = response;
    }
}
exports.HTTPError = HTTPError;
}}),
"[project]/node_modules/ipfs-utils/src/fetch.browser.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/**
 * @typedef {globalThis.Headers} Headers
 * @typedef {globalThis.Request} Request
 * @typedef {globalThis.Response} Response
 */ // use window.fetch if it is available, fall back to node-fetch if not
module.exports = __turbopack_context__.r("[project]/node_modules/ipfs-utils/node_modules/native-fetch/src/index.js [client] (ecmascript)");
}}),
"[project]/node_modules/ipfs-utils/src/http/fetch.browser.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const { TimeoutError, AbortError } = __turbopack_context__.r("[project]/node_modules/ipfs-utils/src/http/error.js [client] (ecmascript)");
// @ts-expect-error
const { Response, Request, Headers, default: fetch } = __turbopack_context__.r("[project]/node_modules/ipfs-utils/src/fetch.browser.js [client] (ecmascript)");
/**
 * @typedef {import('../types').FetchOptions} FetchOptions
 * @typedef {import('../types').ProgressFn} ProgressFn
 */ /**
 * Fetch with progress
 *
 * @param {string | Request} url
 * @param {FetchOptions} [options]
 * @returns {Promise<ResponseWithURL>}
 */ const fetchWithProgress = (url, options = {})=>{
    const request = new XMLHttpRequest();
    request.open(options.method || 'GET', url.toString(), true);
    const { timeout, headers } = options;
    if (timeout && timeout > 0 && timeout < Infinity) {
        request.timeout = timeout;
    }
    if (options.overrideMimeType != null) {
        request.overrideMimeType(options.overrideMimeType);
    }
    if (headers) {
        for (const [name, value] of new Headers(headers)){
            request.setRequestHeader(name, value);
        }
    }
    if (options.signal) {
        options.signal.onabort = ()=>request.abort();
    }
    if (options.onUploadProgress) {
        request.upload.onprogress = options.onUploadProgress;
    }
    // Note: Need to use `arraybuffer` here instead of `blob` because `Blob`
    // instances coming from JSDOM are not compatible with `Response` from
    // node-fetch (which is the setup we get when testing with jest because
    // it uses JSDOM which does not provide a global fetch
    // https://github.com/jsdom/jsdom/issues/1724)
    request.responseType = 'arraybuffer';
    return new Promise((resolve, reject)=>{
        /**
     * @param {Event} event
     */ const handleEvent = (event)=>{
            switch(event.type){
                case 'error':
                    {
                        resolve(Response.error());
                        break;
                    }
                case 'load':
                    {
                        resolve(new ResponseWithURL(request.responseURL, request.response, {
                            status: request.status,
                            statusText: request.statusText,
                            headers: parseHeaders(request.getAllResponseHeaders())
                        }));
                        break;
                    }
                case 'timeout':
                    {
                        reject(new TimeoutError());
                        break;
                    }
                case 'abort':
                    {
                        reject(new AbortError());
                        break;
                    }
                default:
                    {
                        break;
                    }
            }
        };
        request.onerror = handleEvent;
        request.onload = handleEvent;
        request.ontimeout = handleEvent;
        request.onabort = handleEvent;
        // @ts-expect-error options.body can be a node readable stream, which isn't compatible with XHR, but this
        // file is a browser override so you won't get a node readable stream so ignore the error
        request.send(options.body);
    });
};
const fetchWithStreaming = fetch;
/**
 * @param {string | Request} url
 * @param {FetchOptions} options
 */ const fetchWith = (url, options = {})=>options.onUploadProgress != null ? fetchWithProgress(url, options) : fetchWithStreaming(url, options);
/**
 * Parse Headers from a XMLHttpRequest
 *
 * @param {string} input
 * @returns {Headers}
 */ const parseHeaders = (input)=>{
    const headers = new Headers();
    for (const line of input.trim().split(/[\r\n]+/)){
        const index = line.indexOf(': ');
        if (index > 0) {
            headers.set(line.slice(0, index), line.slice(index + 1));
        }
    }
    return headers;
};
class ResponseWithURL extends Response {
    /**
   * @param {string} url
   * @param {BodyInit} body
   * @param {ResponseInit} options
   */ constructor(url, body, options){
        super(body, options);
        Object.defineProperty(this, 'url', {
            value: url
        });
    }
}
module.exports = {
    fetch: fetchWith,
    Request,
    Headers
};
}}),
"[project]/node_modules/ipfs-utils/src/http.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable no-undef */ 'use strict';
const { fetch, Request, Headers } = __turbopack_context__.r("[project]/node_modules/ipfs-utils/src/http/fetch.browser.js [client] (ecmascript)");
const { TimeoutError, HTTPError } = __turbopack_context__.r("[project]/node_modules/ipfs-utils/src/http/error.js [client] (ecmascript)");
const merge = __turbopack_context__.r("[project]/node_modules/merge-options/index.js [client] (ecmascript)").bind({
    ignoreUndefined: true
});
const { URL, URLSearchParams } = __turbopack_context__.r("[project]/node_modules/iso-url/index.js [client] (ecmascript)");
const anySignal = __turbopack_context__.r("[project]/node_modules/any-signal/index.js [client] (ecmascript)");
const browserReableStreamToIt = __turbopack_context__.r("[project]/node_modules/ipfs-utils/node_modules/browser-readablestream-to-it/index.js [client] (ecmascript)");
const { isBrowser, isWebWorker } = __turbopack_context__.r("[project]/node_modules/ipfs-utils/src/env.js [client] (ecmascript)");
const all = __turbopack_context__.r("[project]/node_modules/ipfs-utils/node_modules/it-all/index.js [client] (ecmascript)");
/**
 * @typedef {import('stream').Readable} NodeReadableStream
 * @typedef {import('./types').HTTPOptions} HTTPOptions
 * @typedef {import('./types').ExtendedResponse} ExtendedResponse
 */ /**
 * @template TResponse
 * @param {Promise<TResponse>} promise
 * @param {number | undefined} ms
 * @param {AbortController} abortController
 * @returns {Promise<TResponse>}
 */ const timeout = (promise, ms, abortController)=>{
    if (ms === undefined) {
        return promise;
    }
    const start = Date.now();
    const timedOut = ()=>{
        const time = Date.now() - start;
        return time >= ms;
    };
    return new Promise((resolve, reject)=>{
        const timeoutID = setTimeout(()=>{
            if (timedOut()) {
                reject(new TimeoutError());
                abortController.abort();
            }
        }, ms);
        /**
     * @param {(value: any) => void } next
     */ const after = (next)=>{
            /**
       * @param {any} res
       */ const fn = (res)=>{
                clearTimeout(timeoutID);
                if (timedOut()) {
                    reject(new TimeoutError());
                    return;
                }
                next(res);
            };
            return fn;
        };
        promise.then(after(resolve), after(reject));
    });
};
const defaults = {
    throwHttpErrors: true,
    credentials: 'same-origin'
};
class HTTP {
    /**
   *
   * @param {HTTPOptions} options
   */ constructor(options = {}){
        /** @type {HTTPOptions} */ this.opts = merge(defaults, options);
    }
    /**
   * Fetch
   *
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   * @returns {Promise<ExtendedResponse>}
   */ async fetch(resource, options = {}) {
        /** @type {HTTPOptions} */ const opts = merge(this.opts, options);
        // @ts-expect-error
        const headers = new Headers(opts.headers);
        // validate resource type
        // @ts-expect-error
        if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {
            throw new TypeError('`resource` must be a string, URL, or Request');
        }
        const url = new URL(resource.toString(), opts.base);
        const { searchParams, transformSearchParams, json } = opts;
        if (searchParams) {
            if (typeof transformSearchParams === 'function') {
                // @ts-ignore
                url.search = transformSearchParams(new URLSearchParams(opts.searchParams));
            } else {
                // @ts-ignore
                url.search = new URLSearchParams(opts.searchParams);
            }
        }
        if (json) {
            opts.body = JSON.stringify(opts.json);
            headers.set('content-type', 'application/json');
        }
        const abortController = new AbortController();
        // @ts-ignore
        const signal = anySignal([
            abortController.signal,
            opts.signal
        ]);
        if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser || isWebWorker)) {
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1387483
            opts.body = new Blob(await all(browserReableStreamToIt(opts.body)));
        }
        /** @type {ExtendedResponse} */ // @ts-expect-error additional fields are assigned below
        const response = await timeout(fetch(url.toString(), {
            ...opts,
            signal,
            // @ts-expect-error non-browser fetch implementations may take extra options
            timeout: undefined,
            headers,
            // https://fetch.spec.whatwg.org/#dom-requestinit-duplex
            // https://github.com/whatwg/fetch/issues/1254
            duplex: 'half'
        }), opts.timeout, abortController);
        if (!response.ok && opts.throwHttpErrors) {
            if (opts.handleError) {
                await opts.handleError(response);
            }
            throw new HTTPError(response);
        }
        response.iterator = async function*() {
            yield* fromStream(response.body);
        };
        response.ndjson = async function*() {
            for await (const chunk of ndjson(response.iterator())){
                if (options.transform) {
                    yield options.transform(chunk);
                } else {
                    yield chunk;
                }
            }
        };
        return response;
    }
    /**
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   */ post(resource, options = {}) {
        return this.fetch(resource, {
            ...options,
            method: 'POST'
        });
    }
    /**
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   */ get(resource, options = {}) {
        return this.fetch(resource, {
            ...options,
            method: 'GET'
        });
    }
    /**
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   */ put(resource, options = {}) {
        return this.fetch(resource, {
            ...options,
            method: 'PUT'
        });
    }
    /**
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   */ delete(resource, options = {}) {
        return this.fetch(resource, {
            ...options,
            method: 'DELETE'
        });
    }
    /**
   * @param {string | Request} resource
   * @param {HTTPOptions} options
   */ options(resource, options = {}) {
        return this.fetch(resource, {
            ...options,
            method: 'OPTIONS'
        });
    }
}
/**
 * Parses NDJSON chunks from an iterator
 *
 * @param {AsyncIterable<Uint8Array>} source
 * @returns {AsyncIterable<any>}
 */ const ndjson = async function*(source) {
    const decoder = new TextDecoder();
    let buf = '';
    for await (const chunk of source){
        buf += decoder.decode(chunk, {
            stream: true
        });
        const lines = buf.split(/\r?\n/);
        for(let i = 0; i < lines.length - 1; i++){
            const l = lines[i].trim();
            if (l.length > 0) {
                yield JSON.parse(l);
            }
        }
        buf = lines[lines.length - 1];
    }
    buf += decoder.decode();
    buf = buf.trim();
    if (buf.length !== 0) {
        yield JSON.parse(buf);
    }
};
/**
 * Stream to AsyncIterable
 *
 * @template TChunk
 * @param {ReadableStream<TChunk> | NodeReadableStream | null} source
 * @returns {AsyncIterable<TChunk>}
 */ const fromStream = (source)=>{
    if (isAsyncIterable(source)) {
        return source;
    }
    // Workaround for https://github.com/node-fetch/node-fetch/issues/766
    if (isNodeReadableStream(source)) {
        const iter = source[Symbol.asyncIterator]();
        return {
            [Symbol.asyncIterator] () {
                return {
                    next: iter.next.bind(iter),
                    return (value) {
                        source.destroy();
                        if (typeof iter.return === 'function') {
                            return iter.return();
                        }
                        return Promise.resolve({
                            done: true,
                            value
                        });
                    }
                };
            }
        };
    }
    if (isWebReadableStream(source)) {
        const reader = source.getReader();
        return async function*() {
            try {
                while(true){
                    // Read from the stream
                    const { done, value } = await reader.read();
                    // Exit if we're done
                    if (done) return;
                    // Else yield the chunk
                    if (value) {
                        yield value;
                    }
                }
            } finally{
                reader.releaseLock();
            }
        }();
    }
    throw new TypeError('Body can\'t be converted to AsyncIterable');
};
/**
 * Check if it's an AsyncIterable
 *
 * @template {unknown} TChunk
 * @template {any} Other
 * @param {Other|AsyncIterable<TChunk>} value
 * @returns {value is AsyncIterable<TChunk>}
 */ const isAsyncIterable = (value)=>{
    return typeof value === 'object' && value !== null && typeof /** @type {any} */ value[Symbol.asyncIterator] === 'function';
};
/**
 * Check for web readable stream
 *
 * @template {unknown} TChunk
 * @template {any} Other
 * @param {Other|ReadableStream<TChunk>} value
 * @returns {value is ReadableStream<TChunk>}
 */ const isWebReadableStream = (value)=>{
    return value && typeof /** @type {any} */ value.getReader === 'function';
};
/**
 * @param {any} value
 * @returns {value is NodeReadableStream}
 */ const isNodeReadableStream = (value)=>Object.prototype.hasOwnProperty.call(value, 'readable') && Object.prototype.hasOwnProperty.call(value, 'writable');
HTTP.HTTPError = HTTPError;
HTTP.TimeoutError = TimeoutError;
HTTP.streamToAsyncIterator = fromStream;
/**
 * @param {string | Request} resource
 * @param {HTTPOptions} [options]
 */ HTTP.post = (resource, options)=>new HTTP(options).post(resource, options);
/**
 * @param {string | Request} resource
 * @param {HTTPOptions} [options]
 */ HTTP.get = (resource, options)=>new HTTP(options).get(resource, options);
/**
 * @param {string | Request} resource
 * @param {HTTPOptions} [options]
 */ HTTP.put = (resource, options)=>new HTTP(options).put(resource, options);
/**
 * @param {string | Request} resource
 * @param {HTTPOptions} [options]
 */ HTTP.delete = (resource, options)=>new HTTP(options).delete(resource, options);
/**
 * @param {string | Request} resource
 * @param {HTTPOptions} [options]
 */ HTTP.options = (resource, options)=>new HTTP(options).options(resource, options);
module.exports = HTTP;
}}),
"[project]/node_modules/ipfs-utils/src/files/url-source.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const HTTP = __turbopack_context__.r("[project]/node_modules/ipfs-utils/src/http.js [client] (ecmascript)");
/**
 *
 * @param {string} url
 * @param {import("../types").HTTPOptions} [options]
 * @returns {{ path: string; content?: AsyncIterable<Uint8Array> }}
 */ const urlSource = (url, options)=>{
    return {
        path: decodeURIComponent(new URL(url).pathname.split('/').pop() || ''),
        content: readURLContent(url, options)
    };
};
/**
 *
 * @param {string} url
 * @param {import("../types").HTTPOptions} [options]
 * @returns {AsyncIterable<Uint8Array>}
 */ async function* readURLContent(url, options) {
    const http = new HTTP();
    const response = await http.get(url, options);
    yield* response.iterator();
}
module.exports = urlSource;
}}),
"[project]/node_modules/parse-duration/index.mjs [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
let durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
/**
 * conversion ratios
 */ parse.year = parse.yr = parse.y = 60000 * 60 * 24 * 365.25;
parse.month = parse.b = 60000 * 60 * 24 * (365.25 / 12);
parse.week = parse.wk = parse.w = 60000 * 60 * 24 * 7;
parse.day = parse.d = 60000 * 60 * 24;
parse.hour = parse.hr = parse.h = 60000 * 60;
parse.minute = parse.min = parse.m = 60000;
parse.second = parse.sec = parse.s = 1000;
parse.millisecond = parse.millisec = parse.ms = 1;
parse['µs'] = parse['μs'] = parse.us = parse.microsecond = 1 / 1e3;
parse.nanosecond = parse.ns = 1 / 1e6;
/**
 * convert `str` to ms
 *
 * @param {String} str
 * @param {String} format
 * @return {Number}
 */ function parse(str = '', format = 'ms') {
    var result = null, prevUnits;
    // ignore commas/placeholders
    str = (str + '').replace(/(\d)[,_](\d)/g, '$1$2');
    str.replace(durationRE, function(_, n, units) {
        // if no units, find next smallest units or fall back to format value (ms)
        if (!units) {
            if (prevUnits) {
                for(var u in parse)if (parse[u] < prevUnits) {
                    units = u;
                    break;
                }
            } else units = format;
        } else units = units.toLowerCase();
        if (Object.prototype.hasOwnProperty.call(parse, units)) {
            units = parse[units];
        } else if (Object.prototype.hasOwnProperty.call(parse, units.replace(/s$/, ''))) {
            units = parse[units.replace(/s$/, '')];
        } else {
            units = null;
        }
        if (units) result = (result || 0) + Math.abs(parseFloat(n, 10)) * units, prevUnits = units;
    });
    return result && result / (parse[format] || 1) * (str[0] === '-' ? -1 : 1);
}
const __TURBOPACK__default__export__ = parse;
}}),
"[project]/node_modules/ms/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}}),
"[project]/node_modules/debug/src/common.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/ms/index.js [client] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(' ', ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}}),
"[project]/node_modules/debug/src/browser.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
    }
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && 'env' in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]) {
        r = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [client] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}}),
"[project]/node_modules/@libp2p/logger/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "disable": (()=>disable),
    "enable": (()=>enable),
    "enabled": (()=>enabled),
    "logger": (()=>logger)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/debug/src/browser.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/bases/base58.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base32$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/bases/base32.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base64$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/bases/base64.js [client] (ecmascript)");
;
;
;
;
// Add a formatter for converting to a base58 string
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].formatters.b = (v)=>{
    return v == null ? 'undefined' : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base58btc"].baseEncode(v);
};
// Add a formatter for converting to a base32 string
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].formatters.t = (v)=>{
    return v == null ? 'undefined' : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base32$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base32"].baseEncode(v);
};
// Add a formatter for converting to a base64 string
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].formatters.m = (v)=>{
    return v == null ? 'undefined' : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base64$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base64"].baseEncode(v);
};
// Add a formatter for stringifying peer ids
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].formatters.p = (v)=>{
    return v == null ? 'undefined' : v.toString();
};
// Add a formatter for stringifying CIDs
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].formatters.c = (v)=>{
    return v == null ? 'undefined' : v.toString();
};
// Add a formatter for stringifying Datastore keys
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].formatters.k = (v)=>{
    return v == null ? 'undefined' : v.toString();
};
// Add a formatter for stringifying Multiaddrs
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].formatters.a = (v)=>{
    return v == null ? 'undefined' : v.toString();
};
function createDisabledLogger(namespace) {
    const logger = ()=>{};
    logger.enabled = false;
    logger.color = '';
    logger.diff = 0;
    logger.log = ()=>{};
    logger.namespace = namespace;
    logger.destroy = ()=>true;
    logger.extend = ()=>logger;
    return logger;
}
function logger(name) {
    // trace logging is a no-op by default
    let trace = createDisabledLogger(`${name}:trace`);
    // look at all the debug names and see if trace logging has explicitly been enabled
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].enabled(`${name}:trace`) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].names.map((r)=>r.toString()).find((n)=>n.includes(':trace')) != null) {
        trace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(`${name}:trace`);
    }
    return Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(name), {
        error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(`${name}:error`),
        trace
    });
}
function disable() {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].disable();
}
function enable(namespaces) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].enable(namespaces);
}
function enabled(namespaces) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].enabled(namespaces);
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/node-fetch/browser.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// ref: https://github.com/tc39/proposal-global
var getGlobal = function() {
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('unable to locate global object');
};
var globalObject = getGlobal();
module.exports = exports = globalObject.fetch;
// Needed for TypeScript and Webpack.
if (globalObject.fetch) {
    exports.default = globalObject.fetch.bind(globalObject);
}
exports.Headers = globalObject.Headers;
exports.Request = globalObject.Request;
exports.Response = globalObject.Response;
}}),
"[project]/node_modules/ipfs-utils/node_modules/native-fetch/src/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
    module.exports = {
        default: globalThis.fetch,
        Headers: globalThis.Headers,
        Request: globalThis.Request,
        Response: globalThis.Response
    };
} else {
    module.exports = {
        default: __turbopack_context__.r("[project]/node_modules/node-fetch/browser.js [client] (ecmascript)").default,
        Headers: __turbopack_context__.r("[project]/node_modules/node-fetch/browser.js [client] (ecmascript)").Headers,
        Request: __turbopack_context__.r("[project]/node_modules/node-fetch/browser.js [client] (ecmascript)").Request,
        Response: __turbopack_context__.r("[project]/node_modules/node-fetch/browser.js [client] (ecmascript)").Response
    };
}
}}),
"[project]/node_modules/is-plain-obj/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = (value)=>{
    if (Object.prototype.toString.call(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
};
}}),
"[project]/node_modules/merge-options/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const isOptionObject = __turbopack_context__.r("[project]/node_modules/is-plain-obj/index.js [client] (ecmascript)");
const { hasOwnProperty } = Object.prototype;
const { propertyIsEnumerable } = Object;
const defineProperty = (object, name, value)=>Object.defineProperty(object, name, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
    });
const globalThis = this;
const defaultMergeOptions = {
    concatArrays: false,
    ignoreUndefined: false
};
const getEnumerableOwnPropertyKeys = (value)=>{
    const keys = [];
    for(const key in value){
        if (hasOwnProperty.call(value, key)) {
            keys.push(key);
        }
    }
    /* istanbul ignore else  */ if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol of symbols){
            if (propertyIsEnumerable.call(value, symbol)) {
                keys.push(symbol);
            }
        }
    }
    return keys;
};
function clone(value) {
    if (Array.isArray(value)) {
        return cloneArray(value);
    }
    if (isOptionObject(value)) {
        return cloneOptionObject(value);
    }
    return value;
}
function cloneArray(array) {
    const result = array.slice(0, 0);
    getEnumerableOwnPropertyKeys(array).forEach((key)=>{
        defineProperty(result, key, clone(array[key]));
    });
    return result;
}
function cloneOptionObject(object) {
    const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};
    getEnumerableOwnPropertyKeys(object).forEach((key)=>{
        defineProperty(result, key, clone(object[key]));
    });
    return result;
}
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {string[]} keys keys to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */ const mergeKeys = (merged, source, keys, config)=>{
    keys.forEach((key)=>{
        if (typeof source[key] === 'undefined' && config.ignoreUndefined) {
            return;
        }
        // Do not recurse into prototype chain of merged
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
            defineProperty(merged, key, merge(merged[key], source[key], config));
        } else {
            defineProperty(merged, key, clone(source[key]));
        }
    });
    return merged;
};
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 *
 * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
 */ const concatArrays = (merged, source, config)=>{
    let result = merged.slice(0, 0);
    let resultIndex = 0;
    [
        merged,
        source
    ].forEach((array)=>{
        const indices = [];
        // `result.concat(array)` with cloning
        for(let k = 0; k < array.length; k++){
            if (!hasOwnProperty.call(array, k)) {
                continue;
            }
            indices.push(String(k));
            if (array === merged) {
                // Already cloned
                defineProperty(result, resultIndex++, array[k]);
            } else {
                defineProperty(result, resultIndex++, clone(array[k]));
            }
        }
        // Merge non-index keys
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key)=>!indices.includes(key)), config);
    });
    return result;
};
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */ function merge(merged, source, config) {
    if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config);
    }
    if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
    }
    return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
}
module.exports = function(...options) {
    const config = merge(clone(defaultMergeOptions), this !== globalThis && this || {}, defaultMergeOptions);
    let merged = {
        _: {}
    };
    for (const option of options){
        if (option === undefined) {
            continue;
        }
        if (!isOptionObject(option)) {
            throw new TypeError('`' + option + '` is not an Option Object');
        }
        merged = merge(merged, {
            _: option
        }, config);
    }
    return merged._;
};
}}),
"[project]/node_modules/merge-options/index.mjs [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Thin ESM wrapper for CJS named exports.
 *
 * Ref: https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$merge$2d$options$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/merge-options/index.js [client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$merge$2d$options$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"];
}}),
"[project]/node_modules/iso-url/src/url-browser.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';
function getDefaultBase() {
    if (isReactNative) {
        return 'http://localhost';
    }
    // in some environments i.e. cloudflare workers location is not available
    if (!self.location) {
        return '';
    }
    return self.location.protocol + '//' + self.location.host;
}
const URL = self.URL;
const defaultBase = getDefaultBase();
class URLWithLegacySupport {
    constructor(url = '', base = defaultBase){
        this.super = new URL(url, base);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ':' + this.password : null;
        this.query = this.search && this.search.startsWith('?') ? this.search.slice(1) : null;
    }
    get hash() {
        return this.super.hash;
    }
    get host() {
        return this.super.host;
    }
    get hostname() {
        return this.super.hostname;
    }
    get href() {
        return this.super.href;
    }
    get origin() {
        return this.super.origin;
    }
    get password() {
        return this.super.password;
    }
    get pathname() {
        return this.super.pathname;
    }
    get port() {
        return this.super.port;
    }
    get protocol() {
        return this.super.protocol;
    }
    get search() {
        return this.super.search;
    }
    get searchParams() {
        return this.super.searchParams;
    }
    get username() {
        return this.super.username;
    }
    set hash(hash) {
        this.super.hash = hash;
    }
    set host(host) {
        this.super.host = host;
    }
    set hostname(hostname) {
        this.super.hostname = hostname;
    }
    set href(href) {
        this.super.href = href;
    }
    set password(password) {
        this.super.password = password;
    }
    set pathname(pathname) {
        this.super.pathname = pathname;
    }
    set port(port) {
        this.super.port = port;
    }
    set protocol(protocol) {
        this.super.protocol = protocol;
    }
    set search(search) {
        this.super.search = search;
    }
    set username(username) {
        this.super.username = username;
    }
    /**
   * @param {any} o
   */ static createObjectURL(o) {
        return URL.createObjectURL(o);
    }
    /**
   * @param {string} o
   */ static revokeObjectURL(o) {
        URL.revokeObjectURL(o);
    }
    toJSON() {
        return this.super.toJSON();
    }
    toString() {
        return this.super.toString();
    }
    format() {
        return this.toString();
    }
}
/**
 * @param {string | import('url').UrlObject} obj
 */ function format(obj) {
    if (typeof obj === 'string') {
        const url = new URL(obj);
        return url.toString();
    }
    if (!(obj instanceof URL)) {
        const userPass = // @ts-ignore its not supported in node but we normalise
        obj.username && obj.password ? `${obj.username}:${obj.password}@` : '';
        const auth = obj.auth ? obj.auth + '@' : '';
        const port = obj.port ? ':' + obj.port : '';
        const protocol = obj.protocol ? obj.protocol + '//' : '';
        const host = obj.host || '';
        const hostname = obj.hostname || '';
        const search = obj.search || (obj.query ? '?' + obj.query : '');
        const hash = obj.hash || '';
        const pathname = obj.pathname || '';
        // @ts-ignore - path is not supported in node but we normalise
        const path = obj.path || pathname + search;
        return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash}`;
    }
}
module.exports = {
    URLWithLegacySupport,
    URLSearchParams: self.URLSearchParams,
    defaultBase,
    format
};
}}),
"[project]/node_modules/iso-url/src/relative.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const { URLWithLegacySupport, format } = __turbopack_context__.r("[project]/node_modules/iso-url/src/url-browser.js [client] (ecmascript)");
/**
 * @param {string | undefined} url
 * @param {any} [location]
 * @param {any} [protocolMap]
 * @param {any} [defaultProtocol]
 */ module.exports = (url, location = {}, protocolMap = {}, defaultProtocol)=>{
    let protocol = location.protocol ? location.protocol.replace(':', '') : 'http';
    // Check protocol map
    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':';
    let urlParsed;
    try {
        urlParsed = new URLWithLegacySupport(url);
    } catch (err) {
        urlParsed = {};
    }
    const base = Object.assign({}, location, {
        protocol: protocol || urlParsed.protocol,
        host: location.host || urlParsed.host
    });
    return new URLWithLegacySupport(url, format(base)).toString();
};
}}),
"[project]/node_modules/iso-url/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const { URLWithLegacySupport, format, URLSearchParams, defaultBase } = __turbopack_context__.r("[project]/node_modules/iso-url/src/url-browser.js [client] (ecmascript)");
const relative = __turbopack_context__.r("[project]/node_modules/iso-url/src/relative.js [client] (ecmascript)");
module.exports = {
    URL: URLWithLegacySupport,
    URLSearchParams,
    format,
    relative,
    defaultBase
};
}}),
"[project]/node_modules/any-signal/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Takes an array of AbortSignals and returns a single signal.
 * If any signals are aborted, the returned signal will be aborted.
 * @param {Array<AbortSignal>} signals
 * @returns {AbortSignal}
 */ function anySignal(signals) {
    const controller = new globalThis.AbortController();
    function onAbort() {
        controller.abort();
        for (const signal of signals){
            if (!signal || !signal.removeEventListener) continue;
            signal.removeEventListener('abort', onAbort);
        }
    }
    for (const signal of signals){
        if (!signal || !signal.addEventListener) continue;
        if (signal.aborted) {
            onAbort();
            break;
        }
        signal.addEventListener('abort', onAbort);
    }
    return controller.signal;
}
module.exports = anySignal;
module.exports.anySignal = anySignal;
}}),
"[project]/node_modules/ipfs-utils/node_modules/browser-readablestream-to-it/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/**
 * Turns a browser readable stream into an async iterable. Async iteration over
 * returned iterable will lock give stream, preventing any other consumer from
 * acquiring a reader. The lock will be released if iteration loop is broken. To
 * prevent stream cancelling optional `{ preventCancel: true }` could be passed
 * as a second argument.
 * @template T
 * @param {ReadableStream<T>} stream
 * @param {Object} [options]
 * @param {boolean} [options.preventCancel=boolean]
 * @returns {AsyncIterable<T>}
 */ async function* browserReadableStreamToIt(stream, options = {}) {
    const reader = stream.getReader();
    try {
        while(true){
            const result = await reader.read();
            if (result.done) {
                return;
            }
            yield result.value;
        }
    } finally{
        if (options.preventCancel !== true) {
            reader.cancel();
        }
        reader.releaseLock();
    }
}
module.exports = browserReadableStreamToIt;
}}),
"[project]/node_modules/browser-readablestream-to-it/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @packageDocumentation
 *
 * Allows treating a browser readable stream as an async iterator.
 *
 * @example
 *
 * ```javascript
 * import toIt from 'browser-readablestream-to-it'
 * import all from 'it-all'
 *
 * const content = [0, 1, 2, 3, 4]
 *
 * const stream = new ReadableStream({
 *   start(controller) {
 *     for (let i = 0; i < content.length; i++) {
 *       controller.enqueue(content[i])
 *     }
 *
 *     controller.close()
 *   }
 * })
 *
 * const arr = await all(toIt(stream))
 *
 * console.info(arr) // 0, 1, 2, 3, 4
 * ```
 *
 * ## preventCancel
 *
 * By default a readable stream will have [.cancel](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/cancel) called on it once it has ended or
 * reading has stopped prematurely.
 *
 * To prevent this behaviour, pass `preventCancel: true` as an option:
 *
 * ```javascript
 * const arr = await all(toIt(stream, { preventCancel: true }))
 *
 * console.info(arr) // 0, 1, 2, 3, 4
 * ```
 */ /**
 * Turns a browser readable stream into an async iterable. Async iteration over
 * returned iterable will lock give stream, preventing any other consumer from
 * acquiring a reader. The lock will be released if iteration loop is broken. To
 * prevent stream cancelling optional `{ preventCancel: true }` could be passed
 * as a second argument.
 */ __turbopack_context__.s({
    "default": (()=>browserReadableStreamToIt)
});
async function* browserReadableStreamToIt(stream, options = {}) {
    const reader = stream.getReader();
    try {
        while(true){
            const result = await reader.read();
            if (result.done) {
                return;
            }
            yield result.value;
        }
    } finally{
        if (options.preventCancel !== true) {
            await reader.cancel();
        }
        reader.releaseLock();
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/ipfs-utils/node_modules/it-all/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/**
 * Collects all values from an (async) iterable into an array and returns it.
 *
 * @template T
 * @param {AsyncIterable<T>|Iterable<T>} source
 */ const all = async (source)=>{
    const arr = [];
    for await (const entry of source){
        arr.push(entry);
    }
    return arr;
};
module.exports = all;
}}),
"[project]/node_modules/it-all/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Collects all values from an (async) iterable and returns them as an array
 */ __turbopack_context__.s({
    "default": (()=>all)
});
async function all(source) {
    const arr = [];
    for await (const entry of source){
        arr.push(entry);
    }
    return arr;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/uint8-varint/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable no-fallthrough */ __turbopack_context__.s({
    "decode": (()=>decode),
    "decodeUint8Array": (()=>decodeUint8Array),
    "decodeUint8ArrayList": (()=>decodeUint8ArrayList),
    "encode": (()=>encode),
    "encodeUint8Array": (()=>encodeUint8Array),
    "encodeUint8ArrayList": (()=>encodeUint8ArrayList),
    "encodingLength": (()=>encodingLength)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8-varint/node_modules/uint8arrays/dist/src/alloc.js [client] (ecmascript)");
;
const N1 = Math.pow(2, 7);
const N2 = Math.pow(2, 14);
const N3 = Math.pow(2, 21);
const N4 = Math.pow(2, 28);
const N5 = Math.pow(2, 35);
const N6 = Math.pow(2, 42);
const N7 = Math.pow(2, 49);
/** Most significant bit of a byte */ const MSB = 0x80;
/** Rest of the bits in a byte */ const REST = 0x7f;
function encodingLength(value) {
    if (value < N1) {
        return 1;
    }
    if (value < N2) {
        return 2;
    }
    if (value < N3) {
        return 3;
    }
    if (value < N4) {
        return 4;
    }
    if (value < N5) {
        return 5;
    }
    if (value < N6) {
        return 6;
    }
    if (value < N7) {
        return 7;
    }
    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
        throw new RangeError('Could not encode varint');
    }
    return 8;
}
function encodeUint8Array(value, buf, offset = 0) {
    switch(encodingLength(value)){
        case 8:
            {
                buf[offset++] = value & 0xFF | MSB;
                value /= 128;
            }
        case 7:
            {
                buf[offset++] = value & 0xFF | MSB;
                value /= 128;
            }
        case 6:
            {
                buf[offset++] = value & 0xFF | MSB;
                value /= 128;
            }
        case 5:
            {
                buf[offset++] = value & 0xFF | MSB;
                value /= 128;
            }
        case 4:
            {
                buf[offset++] = value & 0xFF | MSB;
                value >>>= 7;
            }
        case 3:
            {
                buf[offset++] = value & 0xFF | MSB;
                value >>>= 7;
            }
        case 2:
            {
                buf[offset++] = value & 0xFF | MSB;
                value >>>= 7;
            }
        case 1:
            {
                buf[offset++] = value & 0xFF;
                value >>>= 7;
                break;
            }
        default:
            throw new Error('unreachable');
    }
    return buf;
}
function encodeUint8ArrayList(value, buf, offset = 0) {
    switch(encodingLength(value)){
        case 8:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value /= 128;
            }
        case 7:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value /= 128;
            }
        case 6:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value /= 128;
            }
        case 5:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value /= 128;
            }
        case 4:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value >>>= 7;
            }
        case 3:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value >>>= 7;
            }
        case 2:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value >>>= 7;
            }
        case 1:
            {
                buf.set(offset++, value & 0xFF);
                value >>>= 7;
                break;
            }
        default:
            throw new Error('unreachable');
    }
    return buf;
}
function decodeUint8Array(buf, offset) {
    let b = buf[offset];
    let res = 0;
    res += b & REST;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 1];
    res += (b & REST) << 7;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 2];
    res += (b & REST) << 14;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 3];
    res += (b & REST) << 21;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 4];
    res += (b & REST) * N4;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 5];
    res += (b & REST) * N5;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 6];
    res += (b & REST) * N6;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 7];
    res += (b & REST) * N7;
    if (b < MSB) {
        return res;
    }
    throw new RangeError('Could not decode varint');
}
function decodeUint8ArrayList(buf, offset) {
    let b = buf.get(offset);
    let res = 0;
    res += b & REST;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 1);
    res += (b & REST) << 7;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 2);
    res += (b & REST) << 14;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 3);
    res += (b & REST) << 21;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 4);
    res += (b & REST) * N4;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 5);
    res += (b & REST) * N5;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 6);
    res += (b & REST) * N6;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 7);
    res += (b & REST) * N7;
    if (b < MSB) {
        return res;
    }
    throw new RangeError('Could not decode varint');
}
function encode(value, buf, offset = 0) {
    if (buf == null) {
        buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(encodingLength(value));
    }
    if (buf instanceof Uint8Array) {
        return encodeUint8Array(value, buf, offset);
    } else {
        return encodeUint8ArrayList(value, buf, offset);
    }
}
function decode(buf, offset = 0) {
    if (buf instanceof Uint8Array) {
        return decodeUint8Array(buf, offset);
    } else {
        return decodeUint8ArrayList(buf, offset);
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/util.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "allFF": (()=>allFF),
    "deepEqual": (()=>deepEqual),
    "ipToString": (()=>ipToString),
    "maskToHex": (()=>maskToHex),
    "simpleMaskLength": (()=>simpleMaskLength)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/ip.js [client] (ecmascript)");
;
function allFF(a, from, to) {
    let i = 0;
    for (const e of a){
        if (i < from) continue;
        if (i > to) break;
        if (e !== 0xff) return false;
        i++;
    }
    return true;
}
function deepEqual(a, b, from, to) {
    let i = 0;
    for (const e of a){
        if (i < from) continue;
        if (i > to) break;
        if (e !== b[i]) return false;
        i++;
    }
    return true;
}
function ipToString(ip) {
    switch(ip.length){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["IPv4Len"]:
            {
                return ip.join(".");
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["IPv6Len"]:
            {
                const result = [];
                for(let i = 0; i < ip.length; i++){
                    if (i % 2 === 0) {
                        result.push(ip[i].toString(16).padStart(2, "0") + ip[i + 1].toString(16).padStart(2, "0"));
                    }
                }
                return result.join(":");
            }
        default:
            {
                throw new Error("Invalid ip length");
            }
    }
}
function simpleMaskLength(mask) {
    let ones = 0;
    // eslint-disable-next-line prefer-const
    for (let [index, byte] of mask.entries()){
        if (byte === 0xff) {
            ones += 8;
            continue;
        }
        while((byte & 0x80) != 0){
            ones++;
            byte = byte << 1;
        }
        if ((byte & 0x80) != 0) {
            return -1;
        }
        for(let i = index + 1; i < mask.length; i++){
            if (mask[i] != 0) {
                return -1;
            }
        }
        break;
    }
    return ones;
}
function maskToHex(mask) {
    let hex = "0x";
    for (const byte of mask){
        hex += (byte >> 4).toString(16) + (byte & 0x0f).toString(16);
    }
    return hex;
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/ip.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "IPv4Len": (()=>IPv4Len),
    "IPv6Len": (()=>IPv6Len),
    "containsIp": (()=>containsIp),
    "iPv4FromIPv6": (()=>iPv4FromIPv6),
    "ipv4Prefix": (()=>ipv4Prefix),
    "isIPv4mappedIPv6": (()=>isIPv4mappedIPv6),
    "maskIp": (()=>maskIp),
    "maxIPv6Octet": (()=>maxIPv6Octet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/is-ip/lib/parse.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/util.js [client] (ecmascript)");
;
;
const IPv4Len = 4;
const IPv6Len = 16;
const maxIPv6Octet = parseInt("0xFFFF", 16);
const ipv4Prefix = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    255,
    255
]);
function maskIp(ip, mask) {
    if (mask.length === IPv6Len && ip.length === IPv4Len && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["allFF"])(mask, 0, 11)) {
        mask = mask.slice(12);
    }
    if (mask.length === IPv4Len && ip.length === IPv6Len && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["deepEqual"])(ip, ipv4Prefix, 0, 11)) {
        ip = ip.slice(12);
    }
    const n = ip.length;
    if (n != mask.length) {
        throw new Error("Failed to mask ip");
    }
    const out = new Uint8Array(n);
    for(let i = 0; i < n; i++){
        out[i] = ip[i] & mask[i];
    }
    return out;
}
function containsIp(net, ip) {
    if (typeof ip === "string") {
        ip = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseIP"])(ip);
    }
    if (ip == null) throw new Error("Invalid ip");
    if (ip.length !== net.network.length) {
        return false;
    }
    for(let i = 0; i < ip.length; i++){
        if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {
            return false;
        }
    }
    return true;
}
function iPv4FromIPv6(ip) {
    if (!isIPv4mappedIPv6(ip)) {
        throw new Error("Must have 0xffff prefix");
    }
    return ip.slice(12);
}
function isIPv4mappedIPv6(ip) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["deepEqual"])(ip, ipv4Prefix, 0, 11);
} //# sourceMappingURL=ip.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/cidr.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "cidrMask": (()=>cidrMask),
    "parseCidr": (()=>parseCidr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/is-ip/lib/parse.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/ip.js [client] (ecmascript)");
;
;
function parseCidr(s) {
    const [address, maskString] = s.split("/");
    if (!address || !maskString) throw new Error("Failed to parse given CIDR: " + s);
    let ipLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["IPv4Len"];
    let ip = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseIPv4"])(address);
    if (ip == null) {
        ipLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["IPv6Len"];
        ip = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseIPv6"])(address);
        if (ip == null) throw new Error("Failed to parse given CIDR: " + s);
    }
    const m = parseInt(maskString, 10);
    if (Number.isNaN(m) || String(m).length !== maskString.length || m < 0 || m > ipLength * 8) {
        throw new Error("Failed to parse given CIDR: " + s);
    }
    const mask = cidrMask(m, 8 * ipLength);
    return {
        network: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["maskIp"])(ip, mask),
        mask
    };
}
function cidrMask(ones, bits) {
    if (bits !== 8 * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["IPv4Len"] && bits !== 8 * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["IPv6Len"]) throw new Error("Invalid CIDR mask");
    if (ones < 0 || ones > bits) throw new Error("Invalid CIDR mask");
    const l = bits / 8;
    const m = new Uint8Array(l);
    for(let i = 0; i < l; i++){
        if (ones >= 8) {
            m[i] = 0xff;
            ones -= 8;
            continue;
        }
        m[i] = 255 - (0xff >> ones);
        ones = 0;
    }
    return m;
} //# sourceMappingURL=cidr.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/ipnet.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "IpNet": (()=>IpNet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/is-ip/lib/parse.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$cidr$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/cidr.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/ip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/util.js [client] (ecmascript)");
;
;
;
;
class IpNet {
    /**
     *
     * @param ipOrCidr either network ip or full cidr address
     * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address
     */ constructor(ipOrCidr, mask){
        if (mask == null) {
            ({ network: this.network, mask: this.mask } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$cidr$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseCidr"])(ipOrCidr));
        } else {
            const ipResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseIP"])(ipOrCidr);
            if (ipResult == null) {
                throw new Error("Failed to parse network");
            }
            mask = String(mask);
            const m = parseInt(mask, 10);
            if (Number.isNaN(m) || String(m).length !== mask.length || m < 0 || m > ipResult.length * 8) {
                const maskResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseIP"])(mask);
                if (maskResult == null) {
                    throw new Error("Failed to parse mask");
                }
                this.mask = maskResult;
            } else {
                this.mask = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$cidr$2e$js__$5b$client$5d$__$28$ecmascript$29$__["cidrMask"])(m, 8 * ipResult.length);
            }
            this.network = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["maskIp"])(ipResult, this.mask);
        }
    }
    /**
     * Checks if netmask contains ip address
     * @param ip
     * @returns
     */ contains(ip) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["containsIp"])({
            network: this.network,
            mask: this.mask
        }, ip);
    }
    /**Serializes back to string format */ toString() {
        const l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["simpleMaskLength"])(this.mask);
        const mask = l !== -1 ? String(l) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["maskToHex"])(this.mask);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ipToString"])(this.network) + "/" + mask;
    }
} //# sourceMappingURL=ipnet.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "cidrContains": (()=>cidrContains)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ipnet$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/ipnet.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/util.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/ip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$cidr$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/cidr.js [client] (ecmascript)");
;
;
;
;
;
function cidrContains(cidr, ip) {
    const ipnet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ipnet$2e$js__$5b$client$5d$__$28$ecmascript$29$__["IpNet"](cidr);
    return ipnet.contains(ip);
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ipnet$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/ipnet.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/util.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/ip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$cidr$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/cidr.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/index.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @packageDocumentation
 *
 * This module allows easy conversion of Multiaddrs to URLs.
 *
 * @example Converting multiaddrs to URLs
 *
 * ```js
 * import { multiaddrToUri } from '@multiformats/multiaddr-to-uri'
 *
 * console.log(multiaddrToUri('/dnsaddr/protocol.ai/https'))
 * // -> https://protocol.ai
 *
 * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080'))
 * // -> http://127.0.0.1:8080
 *
 * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080', { assumeHttp: false }))
 * // -> tcp://127.0.0.1:8080
 * ```
 *
 * Note:
 *
 * - When `/tcp` is the last (terminating) protocol HTTP is assumed by default (implicit `assumeHttp: true`)
 *   - this means produced URIs will start with `http://` instead of `tcp://`
 *   - passing `{ assumeHttp: false }` disables this behavior
 * - Might be lossy - e.g. a DNSv6 multiaddr
 * - Can throw if the passed multiaddr:
 *   - is not a valid multiaddr
 *   - is not supported as a URI e.g. circuit
 */ __turbopack_context__.s({
    "multiaddrToUri": (()=>multiaddrToUri)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__getProtocol__as__protocols$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript) <export getProtocol as protocols>");
;
function extractSNI(ma) {
    let sniProtoCode;
    try {
        sniProtoCode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__getProtocol__as__protocols$3e$__["protocols"])('sni').code;
    } catch (e) {
        // No SNI protocol in multiaddr
        return null;
    }
    for (const [proto, value] of ma){
        if (proto === sniProtoCode && value !== undefined) {
            return value;
        }
    }
    return null;
}
function hasTLS(ma) {
    return ma.some(([proto, _])=>proto === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__getProtocol__as__protocols$3e$__["protocols"])('tls').code);
}
function interpretNext(headProtoCode, headProtoVal, restMa) {
    const interpreter = interpreters[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__getProtocol__as__protocols$3e$__["protocols"])(headProtoCode).name];
    if (interpreter === undefined) {
        throw new Error(`Can't interpret protocol ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__getProtocol__as__protocols$3e$__["protocols"])(headProtoCode).name}`);
    }
    const restVal = interpreter(headProtoVal, restMa);
    if (headProtoCode === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__getProtocol__as__protocols$3e$__["protocols"])('ip6').code) {
        return `[${restVal}]`;
    }
    return restVal;
}
const interpreters = {
    ip4: (value, restMa)=>value,
    ip6: (value, restMa)=>{
        if (restMa.length === 0) {
            return value;
        }
        return `[${value}]`;
    },
    tcp: (value, restMa)=>{
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`;
    },
    udp: (value, restMa)=>{
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `udp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`;
    },
    dnsaddr: (value, restMa)=>value,
    dns4: (value, restMa)=>value,
    dns6: (value, restMa)=>value,
    dns: (value, restMa)=>value,
    ipfs: (value, restMa)=>{
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/ipfs/${value}`;
    },
    p2p: (value, restMa)=>{
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p/${value}`;
    },
    http: (value, restMa)=>{
        const maHasTLS = hasTLS(restMa);
        const sni = extractSNI(restMa);
        if (maHasTLS && sni !== null) {
            return `https://${sni}`;
        }
        const protocol = maHasTLS ? 'https://' : 'http://';
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
        // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there
        baseVal = baseVal.replace('tcp://', '');
        return `${protocol}${baseVal}`;
    },
    tls: (value, restMa)=>{
        // Noop, the parent context knows that it's tls. We don't need to do
        // anything here
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
    },
    sni: (value, restMa)=>{
        // Noop, the parent context uses the sni information, we don't need to do
        // anything here
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
    },
    https: (value, restMa)=>{
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
        // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there
        baseVal = baseVal.replace('tcp://', '');
        return `https://${baseVal}`;
    },
    ws: (value, restMa)=>{
        const maHasTLS = hasTLS(restMa);
        const sni = extractSNI(restMa);
        if (maHasTLS && sni !== null) {
            return `wss://${sni}`;
        }
        const protocol = maHasTLS ? 'wss://' : 'ws://';
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
        // We are reinterpreting the base, so we need to remove the tcp:// if it's there
        baseVal = baseVal.replace('tcp://', '');
        return `${protocol}${baseVal}`;
    },
    wss: (value, restMa)=>{
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);
        // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there
        baseVal = baseVal.replace('tcp://', '');
        return `wss://${baseVal}`;
    },
    'p2p-websocket-star': (value, restMa)=>{
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-websocket-star`;
    },
    'p2p-webrtc-star': (value, restMa)=>{
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-star`;
    },
    'p2p-webrtc-direct': (value, restMa)=>{
        const tailProto = restMa.pop();
        if (tailProto === undefined) {
            throw new Error('Unexpected end of multiaddr');
        }
        return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-direct`;
    }
};
function multiaddrToUri(input, opts) {
    const ma = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["multiaddr"])(input);
    const parts = ma.stringTuples();
    const head = parts.pop();
    if (head === undefined) {
        throw new Error('Unexpected end of multiaddr');
    }
    const protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__getProtocol__as__protocols$3e$__["protocols"])(head[0]);
    const interpreter = interpreters[protocol.name];
    if (interpreter == null) {
        throw new Error(`No interpreter found for ${protocol.name}`);
    }
    let uri = interpreter(head[1] ?? '', parts);
    if (opts?.assumeHttp !== false && head[0] === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$export__getProtocol__as__protocols$3e$__["protocols"])('tcp').code) {
        // If rightmost proto is tcp, we assume http here
        uri = uri.replace('tcp://', 'http://');
        if (head[1] === '443' || head[1] === '80') {
            if (head[1] === '443') {
                uri = uri.replace('http://', 'https://');
            }
            // Drop the port
            uri = uri.substring(0, uri.lastIndexOf(':'));
        }
    }
    return uri;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@libp2p/interface-peer-id/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isPeerId": (()=>isPeerId),
    "symbol": (()=>symbol)
});
const symbol = Symbol.for('@libp2p/peer-id');
function isPeerId(other) {
    return other != null && Boolean(other[symbol]);
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@libp2p/interfaces/dist/src/errors.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * When this error is thrown it means an operation was aborted,
 * usually in response to the `abort` event being emitted by an
 * AbortSignal.
 */ __turbopack_context__.s({
    "AbortError": (()=>AbortError),
    "CodeError": (()=>CodeError)
});
class AbortError extends Error {
    code;
    type;
    constructor(message = 'The operation was aborted'){
        super(message);
        this.code = AbortError.code;
        this.type = AbortError.type;
    }
    static code = 'ABORT_ERR';
    static type = 'aborted';
}
class CodeError extends Error {
    code;
    props;
    constructor(message, code, props){
        super(message);
        this.code = code;
        this.name = props?.name ?? 'CodeError';
        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions
    }
} //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/@libp2p/peer-id/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createPeerId": (()=>createPeerId),
    "peerIdFromBytes": (()=>peerIdFromBytes),
    "peerIdFromCID": (()=>peerIdFromCID),
    "peerIdFromKeys": (()=>peerIdFromKeys),
    "peerIdFromPeerId": (()=>peerIdFromPeerId),
    "peerIdFromString": (()=>peerIdFromString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$libp2p$2f$interface$2d$peer$2d$id$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@libp2p/interface-peer-id/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$libp2p$2f$interfaces$2f$dist$2f$src$2f$errors$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@libp2p/interfaces/dist/src/errors.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/bases/base58.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/basics.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/basics.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/cid.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$digest$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/hashes/digest.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/hashes/identity.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/hashes/sha2-browser.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/equals.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
const inspect = Symbol.for('nodejs.util.inspect.custom');
const baseDecoder = Object.values(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]).map((codec)=>codec.decoder)// @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141
.reduce((acc, curr)=>acc.or(curr), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"].identity.decoder);
// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv
const LIBP2P_KEY_CODE = 0x72;
const MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
const MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
class PeerIdImpl {
    type;
    multihash;
    privateKey;
    publicKey;
    string;
    constructor(init){
        this.type = init.type;
        this.multihash = init.multihash;
        this.privateKey = init.privateKey;
        // mark string cache as non-enumerable
        Object.defineProperty(this, 'string', {
            enumerable: false,
            writable: true
        });
    }
    get [Symbol.toStringTag]() {
        return `PeerId(${this.toString()})`;
    }
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$libp2p$2f$interface$2d$peer$2d$id$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["symbol"]] = true;
    toString() {
        if (this.string == null) {
            this.string = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base58btc"].encode(this.multihash.bytes).slice(1);
        }
        return this.string;
    }
    // return self-describing String representation
    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
    toCID() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].createV1(LIBP2P_KEY_CODE, this.multihash);
    }
    toBytes() {
        return this.multihash.bytes;
    }
    /**
     * Returns Multiaddr as a JSON string
     */ toJSON() {
        return this.toString();
    }
    /**
     * Checks the equality of `this` peer against a given PeerId
     */ equals(id) {
        if (id instanceof Uint8Array) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this.multihash.bytes, id);
        } else if (typeof id === 'string') {
            return peerIdFromString(id).equals(this);
        } else if (id?.multihash?.bytes != null) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this.multihash.bytes, id.multihash.bytes);
        } else {
            throw new Error('not valid Id');
        }
    }
    /**
     * Returns PeerId as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```js
     * import { peerIdFromString } from '@libp2p/peer-id'
     *
     * console.info(peerIdFromString('QmFoo'))
     * // 'PeerId(QmFoo)'
     * ```
     */ [inspect]() {
        return `PeerId(${this.toString()})`;
    }
}
class RSAPeerIdImpl extends PeerIdImpl {
    type = 'RSA';
    publicKey;
    constructor(init){
        super({
            ...init,
            type: 'RSA'
        });
        this.publicKey = init.publicKey;
    }
}
class Ed25519PeerIdImpl extends PeerIdImpl {
    type = 'Ed25519';
    publicKey;
    constructor(init){
        super({
            ...init,
            type: 'Ed25519'
        });
        this.publicKey = init.multihash.digest;
    }
}
class Secp256k1PeerIdImpl extends PeerIdImpl {
    type = 'secp256k1';
    publicKey;
    constructor(init){
        super({
            ...init,
            type: 'secp256k1'
        });
        this.publicKey = init.multihash.digest;
    }
}
function createPeerId(init) {
    if (init.type === 'RSA') {
        return new RSAPeerIdImpl(init);
    }
    if (init.type === 'Ed25519') {
        return new Ed25519PeerIdImpl(init);
    }
    if (init.type === 'secp256k1') {
        return new Secp256k1PeerIdImpl(init);
    }
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$libp2p$2f$interfaces$2f$dist$2f$src$2f$errors$2e$js__$5b$client$5d$__$28$ecmascript$29$__["CodeError"]('Type must be "RSA", "Ed25519" or "secp256k1"', 'ERR_INVALID_PARAMETERS');
}
function peerIdFromPeerId(other) {
    if (other.type === 'RSA') {
        return new RSAPeerIdImpl(other);
    }
    if (other.type === 'Ed25519') {
        return new Ed25519PeerIdImpl(other);
    }
    if (other.type === 'secp256k1') {
        return new Secp256k1PeerIdImpl(other);
    }
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$libp2p$2f$interfaces$2f$dist$2f$src$2f$errors$2e$js__$5b$client$5d$__$28$ecmascript$29$__["CodeError"]('Not a PeerId', 'ERR_INVALID_PARAMETERS');
}
function peerIdFromString(str, decoder) {
    decoder = decoder ?? baseDecoder;
    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {
        // identity hash ed25519/secp256k1 key or sha2-256 hash of
        // rsa public key - base58btc encoded either way
        const multihash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$digest$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base58btc"].decode(`z${str}`));
        if (str.startsWith('12D')) {
            return new Ed25519PeerIdImpl({
                multihash
            });
        } else if (str.startsWith('16U')) {
            return new Secp256k1PeerIdImpl({
                multihash
            });
        } else {
            return new RSAPeerIdImpl({
                multihash
            });
        }
    }
    return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf) {
    try {
        const multihash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$digest$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(buf);
        if (multihash.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__["identity"].code) {
            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
                return new Ed25519PeerIdImpl({
                    multihash
                });
            } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
                return new Secp256k1PeerIdImpl({
                    multihash
                });
            }
        }
        if (multihash.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sha256"].code) {
            return new RSAPeerIdImpl({
                multihash
            });
        }
    } catch  {
        return peerIdFromCID(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(buf));
    }
    throw new Error('Supplied PeerID CID is invalid');
}
function peerIdFromCID(cid) {
    if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {
        throw new Error('Supplied PeerID CID is invalid');
    }
    const multihash = cid.multihash;
    if (multihash.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sha256"].code) {
        return new RSAPeerIdImpl({
            multihash: cid.multihash
        });
    } else if (multihash.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__["identity"].code) {
        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
            return new Ed25519PeerIdImpl({
                multihash: cid.multihash
            });
        } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
            return new Secp256k1PeerIdImpl({
                multihash: cid.multihash
            });
        }
    }
    throw new Error('Supplied PeerID CID is invalid');
}
async function peerIdFromKeys(publicKey, privateKey) {
    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({
            multihash: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$digest$2e$js__$5b$client$5d$__$28$ecmascript$29$__["create"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__["identity"].code, publicKey),
            privateKey
        });
    }
    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({
            multihash: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$digest$2e$js__$5b$client$5d$__$28$ecmascript$29$__["create"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$identity$2e$js__$5b$client$5d$__$28$ecmascript$29$__["identity"].code, publicKey),
            privateKey
        });
    }
    return new RSAPeerIdImpl({
        multihash: await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sha256"].digest(publicKey),
        publicKey,
        privateKey
    });
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/it-peekable/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>peekableIterator)
});
function peekableIterator(iterable) {
    // @ts-expect-error
    const [iterator, symbol] = iterable[Symbol.asyncIterator] != null ? [
        iterable[Symbol.asyncIterator](),
        Symbol.asyncIterator
    ] : [
        iterable[Symbol.iterator](),
        Symbol.iterator
    ];
    const queue = [];
    // @ts-expect-error
    return {
        peek: ()=>{
            return iterator.next();
        },
        push: (value)=>{
            queue.push(value);
        },
        next: ()=>{
            if (queue.length > 0) {
                return {
                    done: false,
                    value: queue.shift()
                };
            }
            return iterator.next();
        },
        [symbol] () {
            return this;
        }
    };
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/it-map/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Takes an (async) iterable and returns one with each item mapped by the passed
 * function
 */ __turbopack_context__.s({
    "default": (()=>map)
});
async function* map(source, func) {
    for await (const val of source){
        yield func(val);
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@protobufjs/aspromise/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = asPromise;
/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */ /**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */ function asPromise(fn, ctx /*, varargs */ ) {
    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while(index < arguments.length)params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err /*, varargs */ ) {
            if (pending) {
                pending = false;
                if (err) reject(err);
                else {
                    var params = new Array(arguments.length - 1), offset = 0;
                    while(offset < params.length)params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}
}}),
"[project]/node_modules/@protobufjs/base64/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */ var base64 = exports;
/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */ base64.length = function length(string) {
    var p = string.length;
    if (!p) return 0;
    var n = 0;
    while(--p % 4 > 1 && string.charAt(p) === "=")++n;
    return Math.ceil(string.length * 3) / 4 - n;
};
// Base64 encoding table
var b64 = new Array(64);
// Base64 decoding table
var s64 = new Array(123);
// 65..90, 97..122, 48..57, 43, 47
for(var i = 0; i < 64;)s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */ base64.encode = function encode(buffer, start, end) {
    var parts = null, chunk = [];
    var i = 0, j = 0, t; // temporary
    while(start < end){
        var b = buffer[start++];
        switch(j){
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1) chunk[i++] = 61;
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};
var invalidEncoding = "invalid encoding";
/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */ base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, t; // temporary
    for(var i = 0; i < string.length;){
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1) break;
        if ((c = s64[c]) === undefined) throw Error(invalidEncoding);
        switch(j){
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1) throw Error(invalidEncoding);
    return offset - start;
};
/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */ base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};
}}),
"[project]/node_modules/@protobufjs/eventemitter/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = EventEmitter;
/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */ function EventEmitter() {
    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */ this._listeners = {};
}
/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn: fn,
        ctx: ctx || this
    });
    return this;
};
/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined) this._listeners = {};
    else {
        if (fn === undefined) this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for(var i = 0; i < listeners.length;)if (listeners[i].fn === fn) listeners.splice(i, 1);
            else ++i;
        }
    }
    return this;
};
/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [], i = 1;
        for(; i < arguments.length;)args.push(arguments[i++]);
        for(i = 0; i < listeners.length;)listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};
}}),
"[project]/node_modules/@protobufjs/float/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = factory(factory);
/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */ /**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ // Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {
    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([
            -0
        ]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }
        /* istanbul ignore next */ exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */ exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }
        /* istanbul ignore next */ exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */ exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    // float: ieee754
    })();
    else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign) val = -val;
            if (val === 0) writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val)) writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }
        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
             ? sign * 1.401298464324817e-45 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([
            -0
        ]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }
        /* istanbul ignore next */ exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */ exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }
        /* istanbul ignore next */ exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */ exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    // double: ieee754
    })();
    else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign) val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) {
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) {
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024) exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }
        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
             ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
    return exports;
}
// uint helpers
function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
}
function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
}
function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
}
}}),
"[project]/node_modules/@protobufjs/inquire/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = inquire;
/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */ function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length)) return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}
}}),
"[project]/node_modules/@protobufjs/utf8/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */ var utf8 = exports;
/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */ utf8.length = function utf8_length(string) {
    var len = 0, c = 0;
    for(var i = 0; i < string.length; ++i){
        c = string.charCodeAt(i);
        if (c < 128) len += 1;
        else if (c < 2048) len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else len += 3;
    }
    return len;
};
/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */ utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1) return "";
    var parts = null, chunk = [], i = 0, t; // temporary
    while(start < end){
        t = buffer[start++];
        if (t < 128) chunk[i++] = t;
        else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};
/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */ utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset, c1, c2; // character 2
    for(var i = 0; i < string.length; ++i){
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        }
    }
    return offset - start;
};
}}),
"[project]/node_modules/@protobufjs/pool/index.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = pool;
/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */ /**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */ /**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */ function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX) return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) offset = (offset | 7) + 1;
        return buf;
    };
}
}}),
"[project]/node_modules/protobufjs/src/util/longbits.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = LongBits;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [client] (ecmascript)");
/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */ function LongBits(lo, hi) {
    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.
    /**
     * Low bits.
     * @type {number}
     */ this.lo = lo >>> 0;
    /**
     * High bits.
     * @type {number}
     */ this.hi = hi >>> 0;
}
/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */ var zero = LongBits.zero = new LongBits(0, 0);
zero.toNumber = function() {
    return 0;
};
zero.zzEncode = zero.zzDecode = function() {
    return this;
};
zero.length = function() {
    return 1;
};
/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */ var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.fromNumber = function fromNumber(value) {
    if (value === 0) return zero;
    var sign = value < 0;
    if (sign) value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295) hi = 0;
        }
    }
    return new LongBits(lo, hi);
};
/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.from = function from(value) {
    if (typeof value === "number") return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */ if (util.Long) value = util.Long.fromString(value);
        else return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};
/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */ LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo) hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};
/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */ LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {
        low: this.lo | 0,
        high: this.hi | 0,
        unsigned: Boolean(unsigned)
    };
};
var charCodeAt = String.prototype.charCodeAt;
/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */ LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash) return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
};
/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */ LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
};
/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
};
/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
};
/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */ LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
};
}}),
"[project]/node_modules/protobufjs/src/util/minimal.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var util = exports;
// used to return a Promise where callback is omitted
util.asPromise = __turbopack_context__.r("[project]/node_modules/@protobufjs/aspromise/index.js [client] (ecmascript)");
// converts to / from base64 encoded strings
util.base64 = __turbopack_context__.r("[project]/node_modules/@protobufjs/base64/index.js [client] (ecmascript)");
// base class of rpc.Service
util.EventEmitter = __turbopack_context__.r("[project]/node_modules/@protobufjs/eventemitter/index.js [client] (ecmascript)");
// float handling accross browsers
util.float = __turbopack_context__.r("[project]/node_modules/@protobufjs/float/index.js [client] (ecmascript)");
// requires modules optionally and hides the call from bundlers
util.inquire = __turbopack_context__.r("[project]/node_modules/@protobufjs/inquire/index.js [client] (ecmascript)");
// converts to / from utf8 encoded strings
util.utf8 = __turbopack_context__.r("[project]/node_modules/@protobufjs/utf8/index.js [client] (ecmascript)");
// provides a node-like buffer pool in the browser
util.pool = __turbopack_context__.r("[project]/node_modules/@protobufjs/pool/index.js [client] (ecmascript)");
// utility to work with the low and high bits of a 64 bit value
util.LongBits = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/longbits.js [client] (ecmascript)");
/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */ util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */ util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || this; // eslint-disable-line no-invalid-this
/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */ util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes
/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */ util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes
/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */ util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};
/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */ util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};
/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */ util.isObject = function isObject(value) {
    return value && typeof value === "object";
};
/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isset = /**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};
/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */ /**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */ util.Buffer = function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */ return null;
    }
}();
// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;
// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;
/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */ util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */ return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
};
/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */ util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */  : Array;
/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */ /**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */ util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long || /* istanbul ignore next */ util.global.Long || util.inquire("long");
/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */ util.key2Re = /^true|false|0|1$/;
/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */ util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
};
/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */ util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};
/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */ function merge(dst, src, ifNotSet) {
    for(var keys = Object.keys(src), i = 0; i < keys.length; ++i)if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];
    return dst;
}
util.merge = merge;
/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */ util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};
/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */ function newError(name) {
    function CustomError(message, properties) {
        if (!(this instanceof CustomError)) return new CustomError(message, properties);
        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function
        Object.defineProperty(this, "message", {
            get: function() {
                return message;
            }
        });
        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);
        else Object.defineProperty(this, "stack", {
            value: new Error().stack || ""
        });
        if (properties) merge(this, properties);
    }
    CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true
        },
        name: {
            get: function get() {
                return name;
            },
            set: undefined,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true
        },
        toString: {
            value: function value() {
                return this.name + ": " + this.message;
            },
            writable: true,
            enumerable: false,
            configurable: true
        }
    });
    return CustomError;
}
util.newError = newError;
/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */ util.ProtocolError = newError("ProtocolError");
/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */ /**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */ /**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */ util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for(var i = 0; i < fieldNames.length; ++i)fieldMap[fieldNames[i]] = 1;
    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */ return function() {
        for(var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];
    };
};
/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */ /**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */ util.oneOfSetter = function setOneOf(fieldNames) {
    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */ return function(name) {
        for(var i = 0; i < fieldNames.length; ++i)if (fieldNames[i] !== name) delete this[fieldNames[i]];
    };
};
/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */ util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};
// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */ if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */ function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */ function Buffer_allocUnsafe(size) {
        return new Buffer(size);
    };
};
}}),
"[project]/node_modules/protobufjs/src/writer.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = Writer;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [client] (ecmascript)");
var BufferWriter; // cyclic
var LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;
/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */ function Op(fn, len, val) {
    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */ this.fn = fn;
    /**
     * Value byte length.
     * @type {number}
     */ this.len = len;
    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */ this.next = undefined;
    /**
     * Value to write.
     * @type {*}
     */ this.val = val; // type varies
}
/* istanbul ignore next */ function noop() {} // eslint-disable-line no-empty-function
/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */ function State(writer) {
    /**
     * Current head.
     * @type {Writer.Op}
     */ this.head = writer.head;
    /**
     * Current tail.
     * @type {Writer.Op}
     */ this.tail = writer.tail;
    /**
     * Current buffer length.
     * @type {number}
     */ this.len = writer.len;
    /**
     * Next state.
     * @type {State|null}
     */ this.next = writer.states;
}
/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */ function Writer() {
    /**
     * Current length.
     * @type {number}
     */ this.len = 0;
    /**
     * Operations head.
     * @type {Object}
     */ this.head = new Op(noop, 0, 0);
    /**
     * Operations tail
     * @type {Object}
     */ this.tail = this.head;
    /**
     * Linked forked states.
     * @type {Object|null}
     */ this.states = null;
// When a value is written, the writer calculates its byte length and puts it into a linked
// list of operations to perform when finish() is called. This both allows us to allocate
// buffers of the exact required size and reduces the amount of work we have to do compared
// to first calculating over objects and then encoding over objects. In our case, the encoding
// part is just a linked list walk calling operations with already prepared values.
}
var create = function create() {
    return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    } : function create_array() {
        return new Writer();
    };
};
/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */ Writer.create = create();
/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */ Writer.alloc = function alloc(size) {
    return new util.Array(size);
};
// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */ if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */ Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};
function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
    while(val > 127){
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}
/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */ function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
};
/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
     : this.uint32(value);
};
/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf, pos) {
    while(val.hi){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while(val.lo > 127){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}
/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.int64 = Writer.prototype.uint64;
/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};
/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sfixed32 = Writer.prototype.fixed32;
/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sfixed64 = Writer.prototype.fixed64;
/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};
/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};
var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos); // also works for plain array values
} : function writeBytes_for(val, buf, pos) {
    for(var i = 0; i < val.length; ++i)buf[pos + i] = val[i];
};
/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */ Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len) return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};
/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
};
/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */ Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};
/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */ Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
    }
    return this;
};
/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */ Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};
/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */ Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while(head){
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};
Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};
}}),
"[project]/node_modules/protobufjs/src/writer_buffer.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = BufferWriter;
// extends Writer
var Writer = __turbopack_context__.r("[project]/node_modules/protobufjs/src/writer.js [client] (ecmascript)");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [client] (ecmascript)");
/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */ function BufferWriter() {
    Writer.call(this);
}
BufferWriter._configure = function() {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */ BufferWriter.alloc = util._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
    // also works for plain array values
    } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) val.copy(buf, pos, 0, val.length);
        else for(var i = 0; i < val.length;)buf[pos++] = val[i++];
    };
};
/**
 * @override
 */ BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value)) value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len) this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};
function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) util.utf8.write(val, buf, pos);
    else if (buf.utf8Write) buf.utf8Write(val, pos);
    else buf.write(val, pos);
}
/**
 * @override
 */ BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len) this._push(writeStringBuffer, len, value);
    return this;
};
/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */ BufferWriter._configure();
}}),
"[project]/node_modules/protobufjs/src/reader.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = Reader;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [client] (ecmascript)");
var BufferReader; // cyclic
var LongBits = util.LongBits, utf8 = util.utf8;
/* istanbul ignore next */ function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}
/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */ function Reader(buffer) {
    /**
     * Read buffer.
     * @type {Uint8Array}
     */ this.buf = buffer;
    /**
     * Read buffer position.
     * @type {number}
     */ this.pos = 0;
    /**
     * Read buffer length.
     * @type {number}
     */ this.len = buffer.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
} : function create_array(buffer) {
    if (Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
};
var create = function create() {
    return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer);
        })(buffer);
    } : create_array;
};
/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */ Reader.create = create();
Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;
/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        /* istanbul ignore if */ if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
}();
/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};
/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};
/* eslint-disable no-invalid-this */ function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
        for(; i < 4; ++i){
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128) return bits;
        i = 0;
    } else {
        for(; i < 3; ++i){
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) {
        for(; i < 5; ++i){
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
    } else {
        for(; i < 5; ++i){
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
    }
    /* istanbul ignore next */ throw Error("invalid varint encoding");
}
/* eslint-enable no-invalid-this */ /**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */ Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};
function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
}
/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.fixed32 = function read_fixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
};
/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.sfixed32 = function read_sfixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
};
/* eslint-disable no-invalid-this */ function readFixed64() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
/* eslint-enable no-invalid-this */ /**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.float = function read_float() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};
/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.double = function read_double() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */ Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    /* istanbul ignore if */ if (end > this.len) throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf)) return this.buf.slice(start, end);
    if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
};
/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */ Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};
/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */ Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */ if (this.pos + length > this.len) throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
        }while (this.buf[this.pos++] & 128)
    }
    return this;
};
/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */ Reader.prototype.skipType = function(wireType) {
    switch(wireType){
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while((wireType = this.uint32() & 7) !== 4){
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;
        /* istanbul ignore next */ default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};
Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();
    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {
        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }
    });
};
}}),
"[project]/node_modules/protobufjs/src/reader_buffer.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = BufferReader;
// extends Reader
var Reader = __turbopack_context__.r("[project]/node_modules/protobufjs/src/reader.js [client] (ecmascript)");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [client] (ecmascript)");
/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */ function BufferReader(buffer) {
    Reader.call(this, buffer);
/**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */ }
BufferReader._configure = function() {
    /* istanbul ignore else */ if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;
};
/**
 * @override
 */ BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */ BufferReader._configure();
}}),
"[project]/node_modules/protobufjs/src/rpc/service.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = Service;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [client] (ecmascript)");
// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */ /**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */ /**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */ function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */ this.rpcImpl = rpcImpl;
    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */ this.requestDelimited = Boolean(requestDelimited);
    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */ this.responseDelimited = Boolean(responseDelimited);
}
/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */ Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request) throw TypeError("request must be specified");
    var self = this;
    if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);
    if (!self.rpcImpl) {
        setTimeout(function() {
            callback(Error("already ended"));
        }, 0);
        return undefined;
    }
    try {
        return self.rpcImpl(method, requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
            if (err) {
                self.emit("error", err, method);
                return callback(err);
            }
            if (response === null) {
                self.end(/* endedByRPC */ true);
                return undefined;
            }
            if (!(response instanceof responseCtor)) {
                try {
                    response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }
            }
            self.emit("data", response, method);
            return callback(null, response);
        });
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() {
            callback(err);
        }, 0);
        return undefined;
    }
};
/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */ Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};
}}),
"[project]/node_modules/protobufjs/src/rpc.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * Streaming RPC helpers.
 * @namespace
 */ var rpc = exports;
/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */ /**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */ rpc.Service = __turbopack_context__.r("[project]/node_modules/protobufjs/src/rpc/service.js [client] (ecmascript)");
}}),
"[project]/node_modules/protobufjs/src/roots.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = {}; /**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available across modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */ 
}}),
"[project]/node_modules/protobufjs/src/index-minimal.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var protobuf = exports;
/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */ protobuf.build = "minimal";
// Serialization
protobuf.Writer = __turbopack_context__.r("[project]/node_modules/protobufjs/src/writer.js [client] (ecmascript)");
protobuf.BufferWriter = __turbopack_context__.r("[project]/node_modules/protobufjs/src/writer_buffer.js [client] (ecmascript)");
protobuf.Reader = __turbopack_context__.r("[project]/node_modules/protobufjs/src/reader.js [client] (ecmascript)");
protobuf.BufferReader = __turbopack_context__.r("[project]/node_modules/protobufjs/src/reader_buffer.js [client] (ecmascript)");
// Utility
protobuf.util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [client] (ecmascript)");
protobuf.rpc = __turbopack_context__.r("[project]/node_modules/protobufjs/src/rpc.js [client] (ecmascript)");
protobuf.roots = __turbopack_context__.r("[project]/node_modules/protobufjs/src/roots.js [client] (ecmascript)");
protobuf.configure = configure;
/* istanbul ignore next */ /**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */ function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}
// Set up buffer utility according to the environment
configure();
}}),
"[project]/node_modules/protobufjs/minimal.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// minimal library entry point.
"use strict";
module.exports = __turbopack_context__.r("[project]/node_modules/protobufjs/src/index-minimal.js [client] (ecmascript)");
}}),
"[project]/node_modules/ipfs-unixfs/src/unixfs.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*eslint-disable*/ __turbopack_context__.s({
    "Data": (()=>Data),
    "Metadata": (()=>Metadata),
    "UnixTime": (()=>UnixTime),
    "default": (()=>$root)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/protobufjs/minimal.js [client] (ecmascript)");
;
// Common aliases
const $Reader = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Reader, $Writer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].Writer, $util = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].util;
// Exported root namespace
const $root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].roots["ipfs-unixfs"] || (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].roots["ipfs-unixfs"] = {});
const Data = $root.Data = (()=>{
    /**
     * Properties of a Data.
     * @exports IData
     * @interface IData
     * @property {Data.DataType} Type Data Type
     * @property {Uint8Array|null} [Data] Data Data
     * @property {number|null} [filesize] Data filesize
     * @property {Array.<number>|null} [blocksizes] Data blocksizes
     * @property {number|null} [hashType] Data hashType
     * @property {number|null} [fanout] Data fanout
     * @property {number|null} [mode] Data mode
     * @property {IUnixTime|null} [mtime] Data mtime
     */ /**
     * Constructs a new Data.
     * @exports Data
     * @classdesc Represents a Data.
     * @implements IData
     * @constructor
     * @param {IData=} [p] Properties to set
     */ function Data(p) {
        this.blocksizes = [];
        if (p) {
            for(var ks = Object.keys(p), i = 0; i < ks.length; ++i)if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }
    }
    /**
     * Data Type.
     * @member {Data.DataType} Type
     * @memberof Data
     * @instance
     */ Data.prototype.Type = 0;
    /**
     * Data Data.
     * @member {Uint8Array} Data
     * @memberof Data
     * @instance
     */ Data.prototype.Data = $util.newBuffer([]);
    /**
     * Data filesize.
     * @member {number} filesize
     * @memberof Data
     * @instance
     */ Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Data blocksizes.
     * @member {Array.<number>} blocksizes
     * @memberof Data
     * @instance
     */ Data.prototype.blocksizes = $util.emptyArray;
    /**
     * Data hashType.
     * @member {number} hashType
     * @memberof Data
     * @instance
     */ Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Data fanout.
     * @member {number} fanout
     * @memberof Data
     * @instance
     */ Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Data mode.
     * @member {number} mode
     * @memberof Data
     * @instance
     */ Data.prototype.mode = 0;
    /**
     * Data mtime.
     * @member {IUnixTime|null|undefined} mtime
     * @memberof Data
     * @instance
     */ Data.prototype.mtime = null;
    /**
     * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.
     * @function encode
     * @memberof Data
     * @static
     * @param {IData} m Data message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */ Data.encode = function encode(m, w) {
        if (!w) w = $Writer.create();
        w.uint32(8).int32(m.Type);
        if (m.Data != null && Object.hasOwnProperty.call(m, "Data")) w.uint32(18).bytes(m.Data);
        if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize")) w.uint32(24).uint64(m.filesize);
        if (m.blocksizes != null && m.blocksizes.length) {
            for(var i = 0; i < m.blocksizes.length; ++i)w.uint32(32).uint64(m.blocksizes[i]);
        }
        if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType")) w.uint32(40).uint64(m.hashType);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout")) w.uint32(48).uint64(m.fanout);
        if (m.mode != null && Object.hasOwnProperty.call(m, "mode")) w.uint32(56).uint32(m.mode);
        if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime")) $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
        return w;
    };
    /**
     * Decodes a Data message from the specified reader or buffer.
     * @function decode
     * @memberof Data
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {Data} Data
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */ Data.decode = function decode(r, l) {
        if (!(r instanceof $Reader)) r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();
        while(r.pos < c){
            var t = r.uint32();
            switch(t >>> 3){
                case 1:
                    m.Type = r.int32();
                    break;
                case 2:
                    m.Data = r.bytes();
                    break;
                case 3:
                    m.filesize = r.uint64();
                    break;
                case 4:
                    if (!(m.blocksizes && m.blocksizes.length)) m.blocksizes = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while(r.pos < c2)m.blocksizes.push(r.uint64());
                    } else m.blocksizes.push(r.uint64());
                    break;
                case 5:
                    m.hashType = r.uint64();
                    break;
                case 6:
                    m.fanout = r.uint64();
                    break;
                case 7:
                    m.mode = r.uint32();
                    break;
                case 8:
                    m.mtime = $root.UnixTime.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
            }
        }
        if (!m.hasOwnProperty("Type")) throw $util.ProtocolError("missing required 'Type'", {
            instance: m
        });
        return m;
    };
    /**
     * Creates a Data message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Data
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {Data} Data
     */ Data.fromObject = function fromObject(d) {
        if (d instanceof $root.Data) return d;
        var m = new $root.Data();
        switch(d.Type){
            case "Raw":
            case 0:
                m.Type = 0;
                break;
            case "Directory":
            case 1:
                m.Type = 1;
                break;
            case "File":
            case 2:
                m.Type = 2;
                break;
            case "Metadata":
            case 3:
                m.Type = 3;
                break;
            case "Symlink":
            case 4:
                m.Type = 4;
                break;
            case "HAMTShard":
            case 5:
                m.Type = 5;
                break;
        }
        if (d.Data != null) {
            if (typeof d.Data === "string") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
            else if (d.Data.length) m.Data = d.Data;
        }
        if (d.filesize != null) {
            if ($util.Long) (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
            else if (typeof d.filesize === "string") m.filesize = parseInt(d.filesize, 10);
            else if (typeof d.filesize === "number") m.filesize = d.filesize;
            else if (typeof d.filesize === "object") m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
        }
        if (d.blocksizes) {
            if (!Array.isArray(d.blocksizes)) throw TypeError(".Data.blocksizes: array expected");
            m.blocksizes = [];
            for(var i = 0; i < d.blocksizes.length; ++i){
                if ($util.Long) (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
                else if (typeof d.blocksizes[i] === "string") m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
                else if (typeof d.blocksizes[i] === "number") m.blocksizes[i] = d.blocksizes[i];
                else if (typeof d.blocksizes[i] === "object") m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
            }
        }
        if (d.hashType != null) {
            if ($util.Long) (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
            else if (typeof d.hashType === "string") m.hashType = parseInt(d.hashType, 10);
            else if (typeof d.hashType === "number") m.hashType = d.hashType;
            else if (typeof d.hashType === "object") m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
        }
        if (d.fanout != null) {
            if ($util.Long) (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
            else if (typeof d.fanout === "string") m.fanout = parseInt(d.fanout, 10);
            else if (typeof d.fanout === "number") m.fanout = d.fanout;
            else if (typeof d.fanout === "object") m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
        }
        if (d.mode != null) {
            m.mode = d.mode >>> 0;
        }
        if (d.mtime != null) {
            if (typeof d.mtime !== "object") throw TypeError(".Data.mtime: object expected");
            m.mtime = $root.UnixTime.fromObject(d.mtime);
        }
        return m;
    };
    /**
     * Creates a plain object from a Data message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Data
     * @static
     * @param {Data} m Data
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */ Data.toObject = function toObject(m, o) {
        if (!o) o = {};
        var d = {};
        if (o.arrays || o.defaults) {
            d.blocksizes = [];
        }
        if (o.defaults) {
            d.Type = o.enums === String ? "Raw" : 0;
            if (o.bytes === String) d.Data = "";
            else {
                d.Data = [];
                if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);
            }
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.filesize = o.longs === String ? "0" : 0;
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.hashType = o.longs === String ? "0" : 0;
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.fanout = o.longs === String ? "0" : 0;
            d.mode = 0;
            d.mtime = null;
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
            d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        if (m.filesize != null && m.hasOwnProperty("filesize")) {
            if (typeof m.filesize === "number") d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
            else d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
        }
        if (m.blocksizes && m.blocksizes.length) {
            d.blocksizes = [];
            for(var j = 0; j < m.blocksizes.length; ++j){
                if (typeof m.blocksizes[j] === "number") d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
                else d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
            }
        }
        if (m.hashType != null && m.hasOwnProperty("hashType")) {
            if (typeof m.hashType === "number") d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
            else d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
            if (typeof m.fanout === "number") d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
            else d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
        }
        if (m.mode != null && m.hasOwnProperty("mode")) {
            d.mode = m.mode;
        }
        if (m.mtime != null && m.hasOwnProperty("mtime")) {
            d.mtime = $root.UnixTime.toObject(m.mtime, o);
        }
        return d;
    };
    /**
     * Converts this Data to JSON.
     * @function toJSON
     * @memberof Data
     * @instance
     * @returns {Object.<string,*>} JSON object
     */ Data.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].util.toJSONOptions);
    };
    /**
     * DataType enum.
     * @name Data.DataType
     * @enum {number}
     * @property {number} Raw=0 Raw value
     * @property {number} Directory=1 Directory value
     * @property {number} File=2 File value
     * @property {number} Metadata=3 Metadata value
     * @property {number} Symlink=4 Symlink value
     * @property {number} HAMTShard=5 HAMTShard value
     */ Data.DataType = function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Raw"] = 0;
        values[valuesById[1] = "Directory"] = 1;
        values[valuesById[2] = "File"] = 2;
        values[valuesById[3] = "Metadata"] = 3;
        values[valuesById[4] = "Symlink"] = 4;
        values[valuesById[5] = "HAMTShard"] = 5;
        return values;
    }();
    return Data;
})();
const UnixTime = $root.UnixTime = (()=>{
    /**
     * Properties of an UnixTime.
     * @exports IUnixTime
     * @interface IUnixTime
     * @property {number} Seconds UnixTime Seconds
     * @property {number|null} [FractionalNanoseconds] UnixTime FractionalNanoseconds
     */ /**
     * Constructs a new UnixTime.
     * @exports UnixTime
     * @classdesc Represents an UnixTime.
     * @implements IUnixTime
     * @constructor
     * @param {IUnixTime=} [p] Properties to set
     */ function UnixTime(p) {
        if (p) {
            for(var ks = Object.keys(p), i = 0; i < ks.length; ++i)if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }
    }
    /**
     * UnixTime Seconds.
     * @member {number} Seconds
     * @memberof UnixTime
     * @instance
     */ UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * UnixTime FractionalNanoseconds.
     * @member {number} FractionalNanoseconds
     * @memberof UnixTime
     * @instance
     */ UnixTime.prototype.FractionalNanoseconds = 0;
    /**
     * Encodes the specified UnixTime message. Does not implicitly {@link UnixTime.verify|verify} messages.
     * @function encode
     * @memberof UnixTime
     * @static
     * @param {IUnixTime} m UnixTime message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */ UnixTime.encode = function encode(m, w) {
        if (!w) w = $Writer.create();
        w.uint32(8).int64(m.Seconds);
        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds")) w.uint32(21).fixed32(m.FractionalNanoseconds);
        return w;
    };
    /**
     * Decodes an UnixTime message from the specified reader or buffer.
     * @function decode
     * @memberof UnixTime
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {UnixTime} UnixTime
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */ UnixTime.decode = function decode(r, l) {
        if (!(r instanceof $Reader)) r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.UnixTime();
        while(r.pos < c){
            var t = r.uint32();
            switch(t >>> 3){
                case 1:
                    m.Seconds = r.int64();
                    break;
                case 2:
                    m.FractionalNanoseconds = r.fixed32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
            }
        }
        if (!m.hasOwnProperty("Seconds")) throw $util.ProtocolError("missing required 'Seconds'", {
            instance: m
        });
        return m;
    };
    /**
     * Creates an UnixTime message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UnixTime
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {UnixTime} UnixTime
     */ UnixTime.fromObject = function fromObject(d) {
        if (d instanceof $root.UnixTime) return d;
        var m = new $root.UnixTime();
        if (d.Seconds != null) {
            if ($util.Long) (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
            else if (typeof d.Seconds === "string") m.Seconds = parseInt(d.Seconds, 10);
            else if (typeof d.Seconds === "number") m.Seconds = d.Seconds;
            else if (typeof d.Seconds === "object") m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
        }
        if (d.FractionalNanoseconds != null) {
            m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
        }
        return m;
    };
    /**
     * Creates a plain object from an UnixTime message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UnixTime
     * @static
     * @param {UnixTime} m UnixTime
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */ UnixTime.toObject = function toObject(m, o) {
        if (!o) o = {};
        var d = {};
        if (o.defaults) {
            if ($util.Long) {
                var n = new $util.Long(0, 0, false);
                d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.Seconds = o.longs === String ? "0" : 0;
            d.FractionalNanoseconds = 0;
        }
        if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
            if (typeof m.Seconds === "number") d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
            else d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
        }
        if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
            d.FractionalNanoseconds = m.FractionalNanoseconds;
        }
        return d;
    };
    /**
     * Converts this UnixTime to JSON.
     * @function toJSON
     * @memberof UnixTime
     * @instance
     * @returns {Object.<string,*>} JSON object
     */ UnixTime.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].util.toJSONOptions);
    };
    return UnixTime;
})();
const Metadata = $root.Metadata = (()=>{
    /**
     * Properties of a Metadata.
     * @exports IMetadata
     * @interface IMetadata
     * @property {string|null} [MimeType] Metadata MimeType
     */ /**
     * Constructs a new Metadata.
     * @exports Metadata
     * @classdesc Represents a Metadata.
     * @implements IMetadata
     * @constructor
     * @param {IMetadata=} [p] Properties to set
     */ function Metadata(p) {
        if (p) {
            for(var ks = Object.keys(p), i = 0; i < ks.length; ++i)if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }
    }
    /**
     * Metadata MimeType.
     * @member {string} MimeType
     * @memberof Metadata
     * @instance
     */ Metadata.prototype.MimeType = "";
    /**
     * Encodes the specified Metadata message. Does not implicitly {@link Metadata.verify|verify} messages.
     * @function encode
     * @memberof Metadata
     * @static
     * @param {IMetadata} m Metadata message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */ Metadata.encode = function encode(m, w) {
        if (!w) w = $Writer.create();
        if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType")) w.uint32(10).string(m.MimeType);
        return w;
    };
    /**
     * Decodes a Metadata message from the specified reader or buffer.
     * @function decode
     * @memberof Metadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {Metadata} Metadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */ Metadata.decode = function decode(r, l) {
        if (!(r instanceof $Reader)) r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.Metadata();
        while(r.pos < c){
            var t = r.uint32();
            switch(t >>> 3){
                case 1:
                    m.MimeType = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
            }
        }
        return m;
    };
    /**
     * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Metadata
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {Metadata} Metadata
     */ Metadata.fromObject = function fromObject(d) {
        if (d instanceof $root.Metadata) return d;
        var m = new $root.Metadata();
        if (d.MimeType != null) {
            m.MimeType = String(d.MimeType);
        }
        return m;
    };
    /**
     * Creates a plain object from a Metadata message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Metadata
     * @static
     * @param {Metadata} m Metadata
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */ Metadata.toObject = function toObject(m, o) {
        if (!o) o = {};
        var d = {};
        if (o.defaults) {
            d.MimeType = "";
        }
        if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
            d.MimeType = m.MimeType;
        }
        return d;
    };
    /**
     * Converts this Metadata to JSON.
     * @function toJSON
     * @memberof Metadata
     * @instance
     * @returns {Object.<string,*>} JSON object
     */ Metadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].util.toJSONOptions);
    };
    return Metadata;
})();
;
}}),
"[project]/node_modules/ipfs-unixfs/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "UnixFS": (()=>UnixFS),
    "parseMode": (()=>parseMode),
    "parseMtime": (()=>parseMtime)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/err-code/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$unixfs$2f$src$2f$unixfs$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ipfs-unixfs/src/unixfs.js [client] (ecmascript)");
;
;
const PBData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ipfs$2d$unixfs$2f$src$2f$unixfs$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Data"];
/**
 * @typedef {import('./types').Mtime} Mtime
 * @typedef {import('./types').MtimeLike} MtimeLike
 */ const types = [
    'raw',
    'directory',
    'file',
    'metadata',
    'symlink',
    'hamt-sharded-directory'
];
const dirTypes = [
    'directory',
    'hamt-sharded-directory'
];
const DEFAULT_FILE_MODE = parseInt('0644', 8);
const DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);
function parseMode(mode) {
    if (mode == null) {
        return undefined;
    }
    if (typeof mode === 'number') {
        return mode & 0xFFF;
    }
    mode = mode.toString();
    if (mode.substring(0, 1) === '0') {
        // octal string
        return parseInt(mode, 8) & 0xFFF;
    }
    // decimal string
    return parseInt(mode, 10) & 0xFFF;
}
function parseMtime(input) {
    if (input == null) {
        return undefined;
    }
    /** @type {Mtime | undefined} */ let mtime;
    // { secs, nsecs }
    if (input.secs != null) {
        mtime = {
            secs: input.secs,
            nsecs: input.nsecs
        };
    }
    // UnixFS TimeSpec
    if (input.Seconds != null) {
        mtime = {
            secs: input.Seconds,
            nsecs: input.FractionalNanoseconds
        };
    }
    // process.hrtime()
    if (Array.isArray(input)) {
        mtime = {
            secs: input[0],
            nsecs: input[1]
        };
    }
    // Javascript Date
    if (input instanceof Date) {
        const ms = input.getTime();
        const secs = Math.floor(ms / 1000);
        mtime = {
            secs: secs,
            nsecs: (ms - secs * 1000) * 1000
        };
    }
    /*
  TODO: https://github.com/ipfs/aegir/issues/487

  // process.hrtime.bigint()
  if (input instanceof BigInt) {
    const secs = input / BigInt(1e9)
    const nsecs = input - (secs * BigInt(1e9))

    mtime = {
      secs: parseInt(secs.toString()),
      nsecs: parseInt(nsecs.toString())
    }
  }
  */ if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {
        return undefined;
    }
    if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');
    }
    return mtime;
}
class UnixFS {
    /**
   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md
   *
   * @param {Uint8Array} marshaled
   */ static unmarshal(marshaled) {
        const message = PBData.decode(marshaled);
        const decoded = PBData.toObject(message, {
            defaults: false,
            arrays: true,
            longs: Number,
            objects: false
        });
        const data = new UnixFS({
            type: types[decoded.Type],
            data: decoded.Data,
            blockSizes: decoded.blocksizes,
            mode: decoded.mode,
            mtime: decoded.mtime ? {
                secs: decoded.mtime.Seconds,
                nsecs: decoded.mtime.FractionalNanoseconds
            } : undefined
        });
        // make sure we honour the original mode
        data._originalMode = decoded.mode || 0;
        return data;
    }
    /**
   * @param {object} [options]
   * @param {string} [options.type='file']
   * @param {Uint8Array} [options.data]
   * @param {number[]} [options.blockSizes]
   * @param {number} [options.hashType]
   * @param {number} [options.fanout]
   * @param {MtimeLike | null} [options.mtime]
   * @param {number | string} [options.mode]
   */ constructor(options = {
        type: 'file'
    }){
        const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
        if (type && !types.includes(type)) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');
        }
        this.type = type || 'file';
        this.data = data;
        this.hashType = hashType;
        this.fanout = fanout;
        /** @type {number[]} */ this.blockSizes = blockSizes || [];
        this._originalMode = 0;
        this.mode = parseMode(mode);
        if (mtime) {
            this.mtime = parseMtime(mtime);
            if (this.mtime && !this.mtime.nsecs) {
                this.mtime.nsecs = 0;
            }
        }
    }
    /**
   * @param {number | undefined} mode
   */ set mode(mode) {
        this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
        const parsedMode = parseMode(mode);
        if (parsedMode !== undefined) {
            this._mode = parsedMode;
        }
    }
    /**
   * @returns {number | undefined}
   */ get mode() {
        return this._mode;
    }
    isDirectory() {
        return Boolean(this.type && dirTypes.includes(this.type));
    }
    /**
   * @param {number} size
   */ addBlockSize(size) {
        this.blockSizes.push(size);
    }
    /**
   * @param {number} index
   */ removeBlockSize(index) {
        this.blockSizes.splice(index, 1);
    }
    /**
   * Returns `0` for directories or `data.length + sum(blockSizes)` for everything else
   */ fileSize() {
        if (this.isDirectory()) {
            // dirs don't have file size
            return 0;
        }
        let sum = 0;
        this.blockSizes.forEach((size)=>{
            sum += size;
        });
        if (this.data) {
            sum += this.data.length;
        }
        return sum;
    }
    /**
   * encode to protobuf Uint8Array
   */ marshal() {
        let type;
        switch(this.type){
            case 'raw':
                type = PBData.DataType.Raw;
                break;
            case 'directory':
                type = PBData.DataType.Directory;
                break;
            case 'file':
                type = PBData.DataType.File;
                break;
            case 'metadata':
                type = PBData.DataType.Metadata;
                break;
            case 'symlink':
                type = PBData.DataType.Symlink;
                break;
            case 'hamt-sharded-directory':
                type = PBData.DataType.HAMTShard;
                break;
            default:
                throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');
        }
        let data = this.data;
        if (!this.data || !this.data.length) {
            data = undefined;
        }
        let mode;
        if (this.mode != null) {
            mode = this._originalMode & 0xFFFFF000 | (parseMode(this.mode) || 0);
            if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
                mode = undefined;
            }
            if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
                mode = undefined;
            }
        }
        let mtime;
        if (this.mtime != null) {
            const parsed = parseMtime(this.mtime);
            if (parsed) {
                mtime = {
                    Seconds: parsed.secs,
                    FractionalNanoseconds: parsed.nsecs
                };
                if (mtime.FractionalNanoseconds === 0) {
                    delete mtime.FractionalNanoseconds;
                }
            }
        }
        const pbData = {
            Type: type,
            Data: data,
            filesize: this.isDirectory() ? undefined : this.fileSize(),
            blocksizes: this.blockSizes,
            hashType: this.hashType,
            fanout: this.fanout,
            mode,
            mtime
        };
        return PBData.encode(pbData).finish();
    }
}
;
}}),
"[project]/node_modules/it-first/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Returns the first result from an (async) iterable, unless empty, in which
 * case returns `undefined`
 */ __turbopack_context__.s({
    "default": (()=>first)
});
async function first(source) {
    for await (const entry of source){
        return entry;
    }
    return undefined;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/it-last/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Returns the last item of an (async) iterable, unless empty, in which case
 * return `undefined`
 */ __turbopack_context__.s({
    "default": (()=>last)
});
async function last(source) {
    let res;
    for await (const entry of source){
        res = entry;
    }
    return res;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/stream-to-it/source.js [client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = (readable)=>{
    // Node.js stream
    if (readable[Symbol.asyncIterator]) return readable;
    // Browser ReadableStream
    if (readable.getReader) {
        return async function*() {
            const reader = readable.getReader();
            try {
                while(true){
                    const { done, value } = await reader.read();
                    if (done) return;
                    yield value;
                }
            } finally{
                reader.releaseLock();
            }
        }();
    }
    throw new Error('unknown stream');
};
}}),
"[project]/node_modules/blob-to-it/dist/src/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @packageDocumentation
 *
 * Allows reading Blob contents as an async iterator.
 *
 * @example
 *
 * ```javascript
 * import toIt from 'blob-to-it'
 * import all from 'it-all'
 *
 * const content = [ Uint8Array.from([0, 1, 2, 3, 4]) ]
 * const blob = new Blob(content)
 * const arr = await all(toIt(blob))
 *
 * console.info(arr) // [ [ 0, 1, 2, 3, 4 ] ]
 * ```
 */ __turbopack_context__.s({
    "default": (()=>blobToIt)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$browser$2d$readablestream$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/browser-readablestream-to-it/dist/src/index.js [client] (ecmascript)");
;
function blobToIt(blob) {
    if (typeof blob.stream === 'function') {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$browser$2d$readablestream$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(blob.stream());
    }
    // firefox < 69 does not support blob.stream()
    // @ts-expect-error - response.body is optional, but in practice it's a stream.
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$browser$2d$readablestream$2d$to$2d$it$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Response(blob).body);
} //# sourceMappingURL=index.js.map
}}),
}]);

//# sourceMappingURL=node_modules_58f5adb9._.js.map