(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isV4": (()=>isV4),
    "isV6": (()=>isV6),
    "toBytes": (()=>toBytes),
    "toString": (()=>toString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/is-ip/lib/is-ip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)");
;
;
;
const isV4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIPv4"];
const isV6 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIPv6"];
const toBytes = function(ip) {
    let offset = 0;
    ip = ip.toString().trim();
    if (isV4(ip)) {
        const bytes = new Uint8Array(offset + 4);
        ip.split(/\./g).forEach((byte)=>{
            bytes[offset++] = parseInt(byte, 10) & 0xff;
        });
        return bytes;
    }
    if (isV6(ip)) {
        const sections = ip.split(':', 8);
        let i;
        for(i = 0; i < sections.length; i++){
            const isv4 = isV4(sections[i]);
            let v4Buffer;
            if (isv4) {
                v4Buffer = toBytes(sections[i]);
                sections[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(v4Buffer.slice(0, 2), 'base16');
            }
            if (v4Buffer != null && ++i < 8) {
                sections.splice(i, 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(v4Buffer.slice(2, 4), 'base16'));
            }
        }
        if (sections[0] === '') {
            while(sections.length < 8)sections.unshift('0');
        } else if (sections[sections.length - 1] === '') {
            while(sections.length < 8)sections.push('0');
        } else if (sections.length < 8) {
            for(i = 0; i < sections.length && sections[i] !== ''; i++);
            const argv = [
                i,
                1
            ];
            for(i = 9 - sections.length; i > 0; i--){
                argv.push('0');
            }
            sections.splice.apply(sections, argv);
        }
        const bytes = new Uint8Array(offset + 16);
        for(i = 0; i < sections.length; i++){
            const word = parseInt(sections[i], 16);
            bytes[offset++] = word >> 8 & 0xff;
            bytes[offset++] = word & 0xff;
        }
        return bytes;
    }
    throw new Error('invalid ip address');
};
const toString = function(buf, offset = 0, length) {
    offset = ~~offset;
    length = length ?? buf.length - offset;
    const view = new DataView(buf.buffer);
    if (length === 4) {
        const result = [];
        // IPv4
        for(let i = 0; i < length; i++){
            result.push(buf[offset + i]);
        }
        return result.join('.');
    }
    if (length === 16) {
        const result = [];
        // IPv6
        for(let i = 0; i < length; i += 2){
            result.push(view.getUint16(offset + i).toString(16));
        }
        return result.join(':').replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3').replace(/:{3,4}/, '::');
    }
    return '';
}; //# sourceMappingURL=ip.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/is-ip/lib/is-ip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "codes": (()=>codes),
    "createProtocol": (()=>createProtocol),
    "getProtocol": (()=>getProtocol),
    "names": (()=>names),
    "table": (()=>table)
});
const V = -1;
const names = {};
const codes = {};
const table = [
    [
        4,
        32,
        'ip4'
    ],
    [
        6,
        16,
        'tcp'
    ],
    [
        33,
        16,
        'dccp'
    ],
    [
        41,
        128,
        'ip6'
    ],
    [
        42,
        V,
        'ip6zone'
    ],
    [
        43,
        8,
        'ipcidr'
    ],
    [
        53,
        V,
        'dns',
        true
    ],
    [
        54,
        V,
        'dns4',
        true
    ],
    [
        55,
        V,
        'dns6',
        true
    ],
    [
        56,
        V,
        'dnsaddr',
        true
    ],
    [
        132,
        16,
        'sctp'
    ],
    [
        273,
        16,
        'udp'
    ],
    [
        275,
        0,
        'p2p-webrtc-star'
    ],
    [
        276,
        0,
        'p2p-webrtc-direct'
    ],
    [
        277,
        0,
        'p2p-stardust'
    ],
    [
        280,
        0,
        'webrtc'
    ],
    [
        281,
        0,
        'webrtc-w3c'
    ],
    [
        290,
        0,
        'p2p-circuit'
    ],
    [
        301,
        0,
        'udt'
    ],
    [
        302,
        0,
        'utp'
    ],
    [
        400,
        V,
        'unix',
        false,
        true
    ],
    // `ipfs` is added before `p2p` for legacy support.
    // All text representations will default to `p2p`, but `ipfs` will
    // still be supported
    [
        421,
        V,
        'ipfs'
    ],
    // `p2p` is the preferred name for 421, and is now the default
    [
        421,
        V,
        'p2p'
    ],
    [
        443,
        0,
        'https'
    ],
    [
        444,
        96,
        'onion'
    ],
    [
        445,
        296,
        'onion3'
    ],
    [
        446,
        V,
        'garlic64'
    ],
    [
        448,
        0,
        'tls'
    ],
    [
        449,
        V,
        'sni'
    ],
    [
        460,
        0,
        'quic'
    ],
    [
        461,
        0,
        'quic-v1'
    ],
    [
        465,
        0,
        'webtransport'
    ],
    [
        466,
        V,
        'certhash'
    ],
    [
        477,
        0,
        'ws'
    ],
    [
        478,
        0,
        'wss'
    ],
    [
        479,
        0,
        'p2p-websocket-star'
    ],
    [
        480,
        0,
        'http'
    ],
    [
        777,
        V,
        'memory'
    ]
];
// populate tables
table.forEach((row)=>{
    const proto = createProtocol(...row);
    codes[proto.code] = proto;
    names[proto.name] = proto;
});
function createProtocol(code, size, name, resolvable, path) {
    return {
        code,
        size,
        name,
        resolvable: Boolean(resolvable),
        path: Boolean(path)
    };
}
function getProtocol(proto) {
    if (typeof proto === 'number') {
        if (codes[proto] != null) {
            return codes[proto];
        }
        throw new Error(`no protocol with code: ${proto}`);
    } else if (typeof proto === 'string') {
        if (names[proto] != null) {
            return names[proto];
        }
        throw new Error(`no protocol with name: ${proto}`);
    }
    throw new Error(`invalid protocol id type: ${typeof proto}`);
} //# sourceMappingURL=protocols-table.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/convert.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @packageDocumentation
 *
 * Provides methods for converting
 */ __turbopack_context__.s({
    "convert": (()=>convert),
    "convertToBytes": (()=>convertToBytes),
    "convertToString": (()=>convertToString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/is-ip/lib/is-ip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/cid.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base32$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/bases/base32.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/bases/base58.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/basics.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/basics.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$digest$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/hashes/digest.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/from-string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/concat.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
function convert(proto, a) {
    if (a instanceof Uint8Array) {
        return convertToString(proto, a);
    } else {
        return convertToBytes(proto, a);
    }
}
function convertToString(proto, buf) {
    const protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(proto);
    switch(protocol.code){
        case 4:
        case 41:
            return bytes2ip(buf);
        case 42:
            return bytes2str(buf);
        case 6:
        case 273:
        case 33:
        case 132:
            return bytes2port(buf).toString();
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 449:
        case 777:
            return bytes2str(buf);
        case 421:
            return bytes2mh(buf);
        case 444:
            return bytes2onion(buf);
        case 445:
            return bytes2onion(buf);
        case 466:
            return bytes2mb(buf);
        default:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(buf, 'base16'); // no clue. convert to hex
    }
}
function convertToBytes(proto, str) {
    const protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(proto);
    switch(protocol.code){
        case 4:
            return ip2bytes(str);
        case 41:
            return ip2bytes(str);
        case 42:
            return str2bytes(str);
        case 6:
        case 273:
        case 33:
        case 132:
            return port2bytes(parseInt(str, 10));
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 449:
        case 777:
            return str2bytes(str);
        case 421:
            return mh2bytes(str);
        case 444:
            return onion2bytes(str);
        case 445:
            return onion32bytes(str);
        case 466:
            return mb2bytes(str);
        default:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromString"])(str, 'base16'); // no clue. convert from hex
    }
}
const decoders = Object.values(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]).map((c)=>c.decoder);
const anybaseDecoder = function() {
    let acc = decoders[0].or(decoders[1]);
    decoders.slice(2).forEach((d)=>acc = acc.or(d));
    return acc;
}();
function ip2bytes(ipString) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIP"])(ipString)) {
        throw new Error('invalid ip address');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toBytes"])(ipString);
}
function bytes2ip(ipBuff) {
    const ipString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toString"])(ipBuff, 0, ipBuff.length);
    if (ipString == null) {
        throw new Error('ipBuff is required');
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIP"])(ipString)) {
        throw new Error('invalid ip address');
    }
    return ipString;
}
function port2bytes(port) {
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    view.setUint16(0, port);
    return new Uint8Array(buf);
}
function bytes2port(buf) {
    const view = new DataView(buf.buffer);
    return view.getUint16(buf.byteOffset);
}
function str2bytes(str) {
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromString"])(str);
    const size = Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].encode(buf.length));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        size,
        buf
    ], size.length + buf.length);
}
function bytes2str(buf) {
    const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode(buf);
    buf = buf.slice(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode.bytes);
    if (buf.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(buf);
}
function mh2bytes(hash) {
    let mh;
    if (hash[0] === 'Q' || hash[0] === '1') {
        mh = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$hashes$2f$digest$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base58btc"].decode(`z${hash}`)).bytes;
    } else {
        mh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(hash).multihash.bytes;
    }
    // the address is a varint prefixed multihash string representation
    const size = Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].encode(mh.length));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        size,
        mh
    ], size.length + mh.length);
}
function mb2bytes(mbstr) {
    const mb = anybaseDecoder.decode(mbstr);
    const size = Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].encode(mb.length));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        size,
        mb
    ], size.length + mb.length);
}
function bytes2mb(buf) {
    const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode(buf);
    const hash = buf.slice(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode.bytes);
    if (hash.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return 'u' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(hash, 'base64url');
}
/**
 * Converts bytes to bas58btc string
 */ function bytes2mh(buf) {
    const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode(buf);
    const address = buf.slice(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode.bytes);
    if (address.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(address, 'base58btc');
}
function onion2bytes(str) {
    const addr = str.split(':');
    if (addr.length !== 2) {
        throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 16) {
        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
    }
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base32$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base32"].decode('b' + addr[0]);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
        throw new Error('Port number is not in range(1, 65536)');
    }
    const portBuf = port2bytes(port);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        buf,
        portBuf
    ], buf.length + portBuf.length);
}
function onion32bytes(str) {
    const addr = str.split(':');
    if (addr.length !== 2) {
        throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 56) {
        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
    }
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base32$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base32"].decode(`b${addr[0]}`);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
        throw new Error('Port number is not in range(1, 65536)');
    }
    const portBuf = port2bytes(port);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        buf,
        portBuf
    ], buf.length + portBuf.length);
}
function bytes2onion(buf) {
    const addrBytes = buf.slice(0, buf.length - 2);
    const portBytes = buf.slice(buf.length - 2);
    const addr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(addrBytes, 'base32');
    const port = bytes2port(portBytes);
    return `${addr}:${port}`;
} //# sourceMappingURL=convert.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/codec.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ParseError": (()=>ParseError),
    "bytesToString": (()=>bytesToString),
    "bytesToTuples": (()=>bytesToTuples),
    "cleanPath": (()=>cleanPath),
    "fromBytes": (()=>fromBytes),
    "fromString": (()=>fromString),
    "isValidBytes": (()=>isValidBytes),
    "protoFromTuple": (()=>protoFromTuple),
    "sizeForAddr": (()=>sizeForAddr),
    "stringToBytes": (()=>stringToBytes),
    "stringToStringTuples": (()=>stringToStringTuples),
    "stringTuplesToString": (()=>stringTuplesToString),
    "stringTuplesToTuples": (()=>stringTuplesToTuples),
    "tuplesToBytes": (()=>tuplesToBytes),
    "tuplesToStringTuples": (()=>tuplesToStringTuples),
    "validateBytes": (()=>validateBytes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/convert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/concat.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)");
;
;
;
;
;
function stringToStringTuples(str) {
    const tuples = [];
    const parts = str.split('/').slice(1); // skip first empty elem
    if (parts.length === 1 && parts[0] === '') {
        return [];
    }
    for(let p = 0; p < parts.length; p++){
        const part = parts[p];
        const proto = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(part);
        if (proto.size === 0) {
            tuples.push([
                part
            ]);
            continue;
        }
        p++; // advance addr part
        if (p >= parts.length) {
            throw ParseError('invalid address: ' + str);
        }
        // if it's a path proto, take the rest
        if (proto.path === true) {
            tuples.push([
                part,
                // should we need to check each path part to see if it's a proto?
                // This would allow for other protocols to be added after a unix path,
                // however it would have issues if the path had a protocol name in the path
                cleanPath(parts.slice(p).join('/'))
            ]);
            break;
        }
        tuples.push([
            part,
            parts[p]
        ]);
    }
    return tuples;
}
function stringTuplesToString(tuples) {
    const parts = [];
    tuples.map((tup)=>{
        const proto = protoFromTuple(tup);
        parts.push(proto.name);
        if (tup.length > 1 && tup[1] != null) {
            parts.push(tup[1]);
        }
        return null;
    });
    return cleanPath(parts.join('/'));
}
function stringTuplesToTuples(tuples) {
    return tuples.map((tup)=>{
        if (!Array.isArray(tup)) {
            tup = [
                tup
            ];
        }
        const proto = protoFromTuple(tup);
        if (tup.length > 1) {
            return [
                proto.code,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToBytes"])(proto.code, tup[1])
            ];
        }
        return [
            proto.code
        ];
    });
}
function tuplesToStringTuples(tuples) {
    return tuples.map((tup)=>{
        const proto = protoFromTuple(tup);
        if (tup[1] != null) {
            return [
                proto.code,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToString"])(proto.code, tup[1])
            ];
        }
        return [
            proto.code
        ];
    });
}
function tuplesToBytes(tuples) {
    return fromBytes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])(tuples.map((tup)=>{
        const proto = protoFromTuple(tup);
        let buf = Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].encode(proto.code));
        if (tup.length > 1 && tup[1] != null) {
            buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
                buf,
                tup[1]
            ]); // add address buffer
        }
        return buf;
    })));
}
function sizeForAddr(p, addr) {
    if (p.size > 0) {
        return p.size / 8;
    } else if (p.size === 0) {
        return 0;
    } else {
        const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode(addr);
        return size + (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode.bytes ?? 0);
    }
}
function bytesToTuples(buf) {
    const tuples = [];
    let i = 0;
    while(i < buf.length){
        const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode(buf, i);
        const n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode.bytes ?? 0;
        const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(code);
        const size = sizeForAddr(p, buf.slice(i + n));
        if (size === 0) {
            tuples.push([
                code
            ]);
            i += n;
            continue;
        }
        const addr = buf.slice(i + n, i + n + size);
        i += size + n;
        if (i > buf.length) {
            throw ParseError('Invalid address Uint8Array: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(buf, 'base16'));
        }
        // ok, tuple seems good.
        tuples.push([
            code,
            addr
        ]);
    }
    return tuples;
}
function bytesToString(buf) {
    const a = bytesToTuples(buf);
    const b = tuplesToStringTuples(a);
    return stringTuplesToString(b);
}
function stringToBytes(str) {
    str = cleanPath(str);
    const a = stringToStringTuples(str);
    const b = stringTuplesToTuples(a);
    return tuplesToBytes(b);
}
function fromString(str) {
    return stringToBytes(str);
}
function fromBytes(buf) {
    const err = validateBytes(buf);
    if (err != null) {
        throw err;
    }
    return Uint8Array.from(buf); // copy
}
function validateBytes(buf) {
    try {
        bytesToTuples(buf); // try to parse. will throw if breaks
    } catch (err) {
        return err;
    }
}
function isValidBytes(buf) {
    return validateBytes(buf) === undefined;
}
function cleanPath(str) {
    return '/' + str.trim().split('/').filter((a)=>a).join('/');
}
function ParseError(str) {
    return new Error('Error parsing address: ' + str);
}
function protoFromTuple(tup) {
    const proto = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(tup[0]);
    return proto;
} //# sourceMappingURL=codec.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @packageDocumentation
 *
 * An implementation of a Multiaddr in JavaScript
 *
 * @example
 *
 * ```js
 * import { multiaddr } from '@multiformats/multiaddr'
 *
 * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')
 * ```
 */ __turbopack_context__.s({
    "fromNodeAddress": (()=>fromNodeAddress),
    "isMultiaddr": (()=>isMultiaddr),
    "isName": (()=>isName),
    "multiaddr": (()=>multiaddr),
    "resolvers": (()=>resolvers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/codec.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/cid.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/bases/base58.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/err-code/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/equals.js [client] (ecmascript)");
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _DefaultMultiaddr_string, _DefaultMultiaddr_tuples, _DefaultMultiaddr_stringTuples, _a;
;
;
;
;
;
;
;
;
const inspect = Symbol.for('nodejs.util.inspect.custom');
const DNS_CODES = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns').code,
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns4').code,
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns6').code,
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('dnsaddr').code
];
const resolvers = new Map();
const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');
function fromNodeAddress(addr, transport) {
    if (addr == null) {
        throw new Error('requires node address object');
    }
    if (transport == null) {
        throw new Error('requires transport protocol');
    }
    let ip;
    let host = addr.address;
    switch(addr.family){
        case 4:
            ip = 'ip4';
            break;
        case 6:
            ip = 'ip6';
            if (host.includes('%')) {
                const parts = host.split('%');
                if (parts.length !== 2) {
                    throw Error('Multiple ip6 zones in multiaddr');
                }
                host = parts[0];
                const zone = parts[1];
                ip = `/ip6zone/${zone}/ip6`;
            }
            break;
        default:
            throw Error('Invalid addr family, should be 4 or 6.');
    }
    return new DefaultMultiaddr('/' + [
        ip,
        host,
        transport,
        addr.port
    ].join('/'));
}
function isName(addr) {
    if (!isMultiaddr(addr)) {
        return false;
    }
    // if a part of the multiaddr is resolvable, then return true
    return addr.protos().some((proto)=>proto.resolvable);
}
function isMultiaddr(value) {
    return Boolean(value?.[symbol]);
}
/**
 * Creates a {@link Multiaddr} from a {@link MultiaddrInput}
 */ class DefaultMultiaddr {
    constructor(addr){
        _DefaultMultiaddr_string.set(this, void 0);
        _DefaultMultiaddr_tuples.set(this, void 0);
        _DefaultMultiaddr_stringTuples.set(this, void 0);
        this[_a] = true;
        // default
        if (addr == null) {
            addr = '';
        }
        if (addr instanceof Uint8Array) {
            this.bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBytes"])(addr);
        } else if (typeof addr === 'string') {
            if (addr.length > 0 && addr.charAt(0) !== '/') {
                throw new Error(`multiaddr "${addr}" must start with a "/"`);
            }
            this.bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromString"])(addr);
        } else if (isMultiaddr(addr)) {
            this.bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromBytes"])(addr.bytes); // validate + copy buffer
        } else {
            throw new Error('addr must be a string, Buffer, or another Multiaddr');
        }
    }
    toString() {
        if (__classPrivateFieldGet(this, _DefaultMultiaddr_string, "f") == null) {
            __classPrivateFieldSet(this, _DefaultMultiaddr_string, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bytesToString"])(this.bytes), "f");
        }
        return __classPrivateFieldGet(this, _DefaultMultiaddr_string, "f");
    }
    toJSON() {
        return this.toString();
    }
    toOptions() {
        let family;
        let transport;
        let host;
        let port;
        let zone = '';
        const tcp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('tcp');
        const udp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('udp');
        const ip4 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip4');
        const ip6 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip6');
        const dns6 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns6');
        const ip6zone = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip6zone');
        for (const [code, value] of this.stringTuples()){
            if (code === ip6zone.code) {
                zone = `%${value ?? ''}`;
            }
            // default to https when protocol & port are omitted from DNS addrs
            if (DNS_CODES.includes(code)) {
                transport = tcp.name;
                port = 443;
                host = `${value ?? ''}${zone}`;
                family = code === dns6.code ? 6 : 4;
            }
            if (code === tcp.code || code === udp.code) {
                transport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(code).name;
                port = parseInt(value ?? '');
            }
            if (code === ip4.code || code === ip6.code) {
                transport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(code).name;
                host = `${value ?? ''}${zone}`;
                family = code === ip6.code ? 6 : 4;
            }
        }
        if (family == null || transport == null || host == null || port == null) {
            throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
        }
        const opts = {
            family,
            host,
            transport,
            port
        };
        return opts;
    }
    protos() {
        return this.protoCodes().map((code)=>Object.assign({}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(code)));
    }
    protoCodes() {
        const codes = [];
        const buf = this.bytes;
        let i = 0;
        while(i < buf.length){
            const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode(buf, i);
            const n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].decode.bytes ?? 0;
            const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(code);
            const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sizeForAddr"])(p, buf.slice(i + n));
            i += size + n;
            codes.push(code);
        }
        return codes;
    }
    protoNames() {
        return this.protos().map((proto)=>proto.name);
    }
    tuples() {
        if (__classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f") == null) {
            __classPrivateFieldSet(this, _DefaultMultiaddr_tuples, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bytesToTuples"])(this.bytes), "f");
        }
        return __classPrivateFieldGet(this, _DefaultMultiaddr_tuples, "f");
    }
    stringTuples() {
        if (__classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f") == null) {
            __classPrivateFieldSet(this, _DefaultMultiaddr_stringTuples, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["tuplesToStringTuples"])(this.tuples()), "f");
        }
        return __classPrivateFieldGet(this, _DefaultMultiaddr_stringTuples, "f");
    }
    encapsulate(addr) {
        addr = new DefaultMultiaddr(addr);
        return new DefaultMultiaddr(this.toString() + addr.toString());
    }
    decapsulate(addr) {
        const addrString = addr.toString();
        const s = this.toString();
        const i = s.lastIndexOf(addrString);
        if (i < 0) {
            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
        }
        return new DefaultMultiaddr(s.slice(0, i));
    }
    decapsulateCode(code) {
        const tuples = this.tuples();
        for(let i = tuples.length - 1; i >= 0; i--){
            if (tuples[i][0] === code) {
                return new DefaultMultiaddr((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["tuplesToBytes"])(tuples.slice(0, i)));
            }
        }
        return this;
    }
    getPeerId() {
        try {
            const tuples = this.stringTuples().filter((tuple)=>{
                if (tuple[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["names"].ipfs.code) {
                    return true;
                }
                return false;
            });
            // Get the last ipfs tuple ['ipfs', 'peerid string']
            const tuple = tuples.pop();
            if (tuple?.[1] != null) {
                const peerIdStr = tuple[1];
                // peer id is base58btc encoded string but not multibase encoded so add the `z`
                // prefix so we can validate that it is correctly encoded
                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base58btc"].decode(`z${peerIdStr}`), 'base58btc');
                }
                // try to parse peer id as CID
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(peerIdStr).multihash.bytes, 'base58btc');
            }
            return null;
        } catch (e) {
            return null;
        }
    }
    getPath() {
        let path = null;
        try {
            path = this.stringTuples().filter((tuple)=>{
                const proto = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(tuple[0]);
                if (proto.path === true) {
                    return true;
                }
                return false;
            })[0][1];
            if (path == null) {
                path = null;
            }
        } catch  {
            path = null;
        }
        return path;
    }
    equals(addr) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this.bytes, addr.bytes);
    }
    async resolve(options) {
        const resolvableProto = this.protos().find((p)=>p.resolvable);
        // Multiaddr is not resolvable?
        if (resolvableProto == null) {
            return [
                this
            ];
        }
        const resolver = resolvers.get(resolvableProto.name);
        if (resolver == null) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(new Error(`no available resolver for ${resolvableProto.name}`), 'ERR_NO_AVAILABLE_RESOLVER');
        }
        const addresses = await resolver(this, options);
        return addresses.map((a)=>new DefaultMultiaddr(a));
    }
    nodeAddress() {
        const options = this.toOptions();
        if (options.transport !== 'tcp' && options.transport !== 'udp') {
            throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
        }
        return {
            family: options.family,
            address: options.host,
            port: options.port
        };
    }
    isThinWaistAddress(addr) {
        const protos = (addr ?? this).protos();
        if (protos.length !== 2) {
            return false;
        }
        if (protos[0].code !== 4 && protos[0].code !== 41) {
            return false;
        }
        if (protos[1].code !== 6 && protos[1].code !== 273) {
            return false;
        }
        return true;
    }
    /**
     * Returns Multiaddr as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```js
     * import { multiaddr } from '@multiformats/multiaddr'
     *
     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
     * ```
     */ [(_DefaultMultiaddr_string = new WeakMap(), _DefaultMultiaddr_tuples = new WeakMap(), _DefaultMultiaddr_stringTuples = new WeakMap(), _a = symbol, inspect)]() {
        return `Multiaddr(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bytesToString"])(this.bytes)})`;
    }
}
function multiaddr(addr) {
    return new DefaultMultiaddr(addr);
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/codec.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/src/bases/base58.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$err$2d$code$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/err-code/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/dist/src/equals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/ip.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isV4": (()=>isV4),
    "isV6": (()=>isV6),
    "toBytes": (()=>toBytes),
    "toString": (()=>toString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/is-ip/lib/is-ip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)");
;
;
;
const isV4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIPv4"];
const isV6 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIPv6"];
const toBytes = function(ip) {
    let offset = 0;
    ip = ip.toString().trim();
    if (isV4(ip)) {
        const bytes = new Uint8Array(offset + 4);
        ip.split(/\./g).forEach((byte)=>{
            bytes[offset++] = parseInt(byte, 10) & 0xff;
        });
        return bytes;
    }
    if (isV6(ip)) {
        const sections = ip.split(':', 8);
        let i;
        for(i = 0; i < sections.length; i++){
            const isv4 = isV4(sections[i]);
            let v4Buffer;
            if (isv4) {
                v4Buffer = toBytes(sections[i]);
                sections[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(v4Buffer.slice(0, 2), 'base16');
            }
            if (v4Buffer != null && ++i < 8) {
                sections.splice(i, 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(v4Buffer.slice(2, 4), 'base16'));
            }
        }
        if (sections[0] === '') {
            while(sections.length < 8)sections.unshift('0');
        } else if (sections[sections.length - 1] === '') {
            while(sections.length < 8)sections.push('0');
        } else if (sections.length < 8) {
            for(i = 0; i < sections.length && sections[i] !== ''; i++);
            const argv = [
                i,
                1
            ];
            for(i = 9 - sections.length; i > 0; i--){
                argv.push('0');
            }
            sections.splice.apply(sections, argv);
        }
        const bytes = new Uint8Array(offset + 16);
        for(i = 0; i < sections.length; i++){
            const word = parseInt(sections[i], 16);
            bytes[offset++] = word >> 8 & 0xff;
            bytes[offset++] = word & 0xff;
        }
        return bytes;
    }
    throw new Error('invalid ip address');
};
const toString = function(buf, offset = 0, length) {
    offset = ~~offset;
    length = length ?? buf.length - offset;
    const view = new DataView(buf.buffer);
    if (length === 4) {
        const result = [];
        // IPv4
        for(let i = 0; i < length; i++){
            result.push(buf[offset + i]);
        }
        return result.join('.');
    }
    if (length === 16) {
        const result = [];
        // IPv6
        for(let i = 0; i < length; i += 2){
            result.push(view.getUint16(offset + i).toString(16));
        }
        return result.join(':').replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3').replace(/:{3,4}/, '::');
    }
    return '';
}; //# sourceMappingURL=ip.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/ip.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/is-ip/lib/is-ip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/ip.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "codes": (()=>codes),
    "createProtocol": (()=>createProtocol),
    "getProtocol": (()=>getProtocol),
    "names": (()=>names),
    "table": (()=>table)
});
const V = -1;
const names = {};
const codes = {};
const table = [
    [
        4,
        32,
        'ip4'
    ],
    [
        6,
        16,
        'tcp'
    ],
    [
        33,
        16,
        'dccp'
    ],
    [
        41,
        128,
        'ip6'
    ],
    [
        42,
        V,
        'ip6zone'
    ],
    [
        43,
        8,
        'ipcidr'
    ],
    [
        53,
        V,
        'dns',
        true
    ],
    [
        54,
        V,
        'dns4',
        true
    ],
    [
        55,
        V,
        'dns6',
        true
    ],
    [
        56,
        V,
        'dnsaddr',
        true
    ],
    [
        132,
        16,
        'sctp'
    ],
    [
        273,
        16,
        'udp'
    ],
    [
        275,
        0,
        'p2p-webrtc-star'
    ],
    [
        276,
        0,
        'p2p-webrtc-direct'
    ],
    [
        277,
        0,
        'p2p-stardust'
    ],
    [
        280,
        0,
        'webrtc-direct'
    ],
    [
        281,
        0,
        'webrtc'
    ],
    [
        290,
        0,
        'p2p-circuit'
    ],
    [
        301,
        0,
        'udt'
    ],
    [
        302,
        0,
        'utp'
    ],
    [
        400,
        V,
        'unix',
        false,
        true
    ],
    // `ipfs` is added before `p2p` for legacy support.
    // All text representations will default to `p2p`, but `ipfs` will
    // still be supported
    [
        421,
        V,
        'ipfs'
    ],
    // `p2p` is the preferred name for 421, and is now the default
    [
        421,
        V,
        'p2p'
    ],
    [
        443,
        0,
        'https'
    ],
    [
        444,
        96,
        'onion'
    ],
    [
        445,
        296,
        'onion3'
    ],
    [
        446,
        V,
        'garlic64'
    ],
    [
        448,
        0,
        'tls'
    ],
    [
        449,
        V,
        'sni'
    ],
    [
        460,
        0,
        'quic'
    ],
    [
        461,
        0,
        'quic-v1'
    ],
    [
        465,
        0,
        'webtransport'
    ],
    [
        466,
        V,
        'certhash'
    ],
    [
        477,
        0,
        'ws'
    ],
    [
        478,
        0,
        'wss'
    ],
    [
        479,
        0,
        'p2p-websocket-star'
    ],
    [
        480,
        0,
        'http'
    ],
    [
        481,
        V,
        'http-path'
    ],
    [
        777,
        V,
        'memory'
    ]
];
// populate tables
table.forEach((row)=>{
    const proto = createProtocol(...row);
    codes[proto.code] = proto;
    names[proto.name] = proto;
});
function createProtocol(code, size, name, resolvable, path) {
    return {
        code,
        size,
        name,
        resolvable: Boolean(resolvable),
        path: Boolean(path)
    };
}
function getProtocol(proto) {
    if (typeof proto === 'number') {
        if (codes[proto] != null) {
            return codes[proto];
        }
        throw new Error(`no protocol with code: ${proto}`);
    } else if (typeof proto === 'string') {
        if (names[proto] != null) {
            return names[proto];
        }
        throw new Error(`no protocol with name: ${proto}`);
    }
    throw new Error(`invalid protocol id type: ${typeof proto}`);
} //# sourceMappingURL=protocols-table.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/convert.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "convert": (()=>convert),
    "convertToBytes": (()=>convertToBytes),
    "convertToIpNet": (()=>convertToIpNet),
    "convertToString": (()=>convertToString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ipnet$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/netmask/dist/src/ipnet.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base32.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base58.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/basics.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/basics.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/hashes/digest.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8-varint/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/concat.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/from-string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/ip.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chainsafe/is-ip/lib/is-ip.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/ip.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
const ip4Protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip4');
const ip6Protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip6');
const ipcidrProtocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('ipcidr');
function convert(proto, a) {
    if (a instanceof Uint8Array) {
        return convertToString(proto, a);
    } else {
        return convertToBytes(proto, a);
    }
}
function convertToString(proto, buf) {
    const protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(proto);
    switch(protocol.code){
        case 4:
        case 41:
            return bytes2ip(buf);
        case 42:
            return bytes2str(buf);
        case 43:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(buf, 'base10');
        case 6:
        case 273:
        case 33:
        case 132:
            return bytes2port(buf).toString();
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 449:
        case 777:
            return bytes2str(buf);
        case 421:
            return bytes2mh(buf);
        case 444:
            return bytes2onion(buf);
        case 445:
            return bytes2onion(buf);
        case 466:
            return bytes2mb(buf);
        case 481:
            return globalThis.encodeURIComponent(bytes2str(buf));
        default:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(buf, 'base16'); // no clue. convert to hex
    }
}
function convertToBytes(proto, str) {
    const protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(proto);
    switch(protocol.code){
        case 4:
            return ip2bytes(str);
        case 41:
            return ip2bytes(str);
        case 42:
            return str2bytes(str);
        case 43:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromString"])(str, 'base10');
        case 6:
        case 273:
        case 33:
        case 132:
            return port2bytes(parseInt(str, 10));
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 449:
        case 777:
            return str2bytes(str);
        case 421:
            return mh2bytes(str);
        case 444:
            return onion2bytes(str);
        case 445:
            return onion32bytes(str);
        case 466:
            return mb2bytes(str);
        case 481:
            return str2bytes(globalThis.decodeURIComponent(str));
        default:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromString"])(str, 'base16'); // no clue. convert from hex
    }
}
function convertToIpNet(multiaddr) {
    let mask;
    let addr;
    multiaddr.stringTuples().forEach(([code, value])=>{
        if (code === ip4Protocol.code || code === ip6Protocol.code) {
            addr = value;
        }
        if (code === ipcidrProtocol.code) {
            mask = value;
        }
    });
    if (mask == null || addr == null) {
        throw new Error('Invalid multiaddr');
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ipnet$2e$js__$5b$client$5d$__$28$ecmascript$29$__["IpNet"](addr, mask);
}
const decoders = Object.values(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]).map((c)=>c.decoder);
const anybaseDecoder = function() {
    let acc = decoders[0].or(decoders[1]);
    decoders.slice(2).forEach((d)=>acc = acc.or(d));
    return acc;
}();
function ip2bytes(ipString) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIP"])(ipString)) {
        throw new Error('invalid ip address');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toBytes"])(ipString);
}
function bytes2ip(ipBuff) {
    const ipString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toString"])(ipBuff, 0, ipBuff.length);
    if (ipString == null) {
        throw new Error('ipBuff is required');
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isIP"])(ipString)) {
        throw new Error('invalid ip address');
    }
    return ipString;
}
function port2bytes(port) {
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    view.setUint16(0, port);
    return new Uint8Array(buf);
}
function bytes2port(buf) {
    const view = new DataView(buf.buffer);
    return view.getUint16(buf.byteOffset);
}
function str2bytes(str) {
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fromString"])(str);
    const size = Uint8Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encode"])(buf.length));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        size,
        buf
    ], size.length + buf.length);
}
function bytes2str(buf) {
    const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(buf);
    buf = buf.slice((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodingLength"])(size));
    if (buf.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(buf);
}
function mh2bytes(hash) {
    let mh;
    if (hash[0] === 'Q' || hash[0] === '1') {
        mh = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base58btc"].decode(`z${hash}`)).bytes;
    } else {
        mh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(hash).multihash.bytes;
    }
    // the address is a varint prefixed multihash string representation
    const size = Uint8Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encode"])(mh.length));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        size,
        mh
    ], size.length + mh.length);
}
function mb2bytes(mbstr) {
    const mb = anybaseDecoder.decode(mbstr);
    const size = Uint8Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encode"])(mb.length));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        size,
        mb
    ], size.length + mb.length);
}
function bytes2mb(buf) {
    const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(buf);
    const hash = buf.slice((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodingLength"])(size));
    if (hash.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return 'u' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(hash, 'base64url');
}
/**
 * Converts bytes to bas58btc string
 */ function bytes2mh(buf) {
    const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(buf);
    const address = buf.slice((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodingLength"])(size));
    if (address.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(address, 'base58btc');
}
function onion2bytes(str) {
    const addr = str.split(':');
    if (addr.length !== 2) {
        throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 16) {
        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
    }
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base32"].decode('b' + addr[0]);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
        throw new Error('Port number is not in range(1, 65536)');
    }
    const portBuf = port2bytes(port);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        buf,
        portBuf
    ], buf.length + portBuf.length);
}
function onion32bytes(str) {
    const addr = str.split(':');
    if (addr.length !== 2) {
        throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 56) {
        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
    }
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base32"].decode(`b${addr[0]}`);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
        throw new Error('Port number is not in range(1, 65536)');
    }
    const portBuf = port2bytes(port);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        buf,
        portBuf
    ], buf.length + portBuf.length);
}
function bytes2onion(buf) {
    const addrBytes = buf.slice(0, buf.length - 2);
    const portBytes = buf.slice(buf.length - 2);
    const addr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(addrBytes, 'base32');
    const port = bytes2port(portBytes);
    return `${addr}:${port}`;
} //# sourceMappingURL=convert.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/codec.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ParseError": (()=>ParseError),
    "bytesToMultiaddrParts": (()=>bytesToMultiaddrParts),
    "bytesToTuples": (()=>bytesToTuples),
    "cleanPath": (()=>cleanPath),
    "stringToMultiaddrParts": (()=>stringToMultiaddrParts),
    "stringTuplesToTuples": (()=>stringTuplesToTuples),
    "tuplesToBytes": (()=>tuplesToBytes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8-varint/dist/src/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/concat.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/convert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)");
;
;
;
;
;
function stringToMultiaddrParts(str) {
    str = cleanPath(str);
    const tuples = [];
    const stringTuples = [];
    let path = null;
    const parts = str.split('/').slice(1);
    if (parts.length === 1 && parts[0] === '') {
        return {
            bytes: new Uint8Array(),
            string: '/',
            tuples: [],
            stringTuples: [],
            path: null
        };
    }
    for(let p = 0; p < parts.length; p++){
        const part = parts[p];
        const proto = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(part);
        if (proto.size === 0) {
            tuples.push([
                proto.code
            ]);
            stringTuples.push([
                proto.code
            ]);
            continue;
        }
        p++; // advance addr part
        if (p >= parts.length) {
            throw new ParseError('invalid address: ' + str);
        }
        // if it's a path proto, take the rest
        if (proto.path === true) {
            // should we need to check each path part to see if it's a proto?
            // This would allow for other protocols to be added after a unix path,
            // however it would have issues if the path had a protocol name in the path
            path = cleanPath(parts.slice(p).join('/'));
            tuples.push([
                proto.code,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToBytes"])(proto.code, path)
            ]);
            stringTuples.push([
                proto.code,
                path
            ]);
            break;
        }
        const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToBytes"])(proto.code, parts[p]);
        tuples.push([
            proto.code,
            bytes
        ]);
        stringTuples.push([
            proto.code,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToString"])(proto.code, bytes)
        ]);
    }
    return {
        string: stringTuplesToString(stringTuples),
        bytes: tuplesToBytes(tuples),
        tuples,
        stringTuples,
        path
    };
}
function bytesToMultiaddrParts(bytes) {
    const tuples = [];
    const stringTuples = [];
    let path = null;
    let i = 0;
    while(i < bytes.length){
        const code = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(bytes, i);
        const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodingLength"])(code);
        const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(code);
        const size = sizeForAddr(p, bytes.slice(i + n));
        if (size === 0) {
            tuples.push([
                code
            ]);
            stringTuples.push([
                code
            ]);
            i += n;
            continue;
        }
        const addr = bytes.slice(i + n, i + n + size);
        i += size + n;
        if (i > bytes.length) {
            throw new ParseError('Invalid address Uint8Array: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(bytes, 'base16'));
        }
        // ok, tuple seems good.
        tuples.push([
            code,
            addr
        ]);
        const stringAddr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToString"])(code, addr);
        stringTuples.push([
            code,
            stringAddr
        ]);
        if (p.path === true) {
            // should we need to check each path part to see if it's a proto?
            // This would allow for other protocols to be added after a unix path,
            // however it would have issues if the path had a protocol name in the path
            path = stringAddr;
            break;
        }
    }
    return {
        bytes: Uint8Array.from(bytes),
        string: stringTuplesToString(stringTuples),
        tuples,
        stringTuples,
        path
    };
}
function stringTuplesToTuples(stringTuples) {
    const tuples = [];
    stringTuples.forEach(([code, value])=>{
        const tuple = [
            code
        ];
        if (value != null) {
            tuple[1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToBytes"])(code, value);
        }
        tuples.push(tuple);
    });
    return tuples;
}
/**
 * [[num code, str value?]... ] -> string
 */ function stringTuplesToString(tuples) {
    const parts = [];
    tuples.map((tup)=>{
        const proto = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(tup[0]);
        parts.push(proto.name);
        if (tup.length > 1 && tup[1] != null) {
            parts.push(tup[1]);
        }
        return null;
    });
    return cleanPath(parts.join('/'));
}
function tuplesToBytes(tuples) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])(tuples.map((tup)=>{
        const proto = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(tup[0]);
        let buf = Uint8Array.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encode"])(proto.code));
        if (tup.length > 1 && tup[1] != null) {
            buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
                buf,
                tup[1]
            ]); // add address buffer
        }
        return buf;
    }));
}
/**
 * For the passed address, return the serialized size
 */ function sizeForAddr(p, addr) {
    if (p.size > 0) {
        return p.size / 8;
    } else if (p.size === 0) {
        return 0;
    } else {
        const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(addr instanceof Uint8Array ? addr : Uint8Array.from(addr));
        return size + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodingLength"])(size);
    }
}
function bytesToTuples(buf) {
    const tuples = [];
    let i = 0;
    while(i < buf.length){
        const code = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decode"])(buf, i);
        const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodingLength"])(code);
        const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(code);
        const size = sizeForAddr(p, buf.slice(i + n));
        if (size === 0) {
            tuples.push([
                code
            ]);
            i += n;
            continue;
        }
        const addr = buf.slice(i + n, i + n + size);
        i += size + n;
        if (i > buf.length) {
            throw new ParseError('Invalid address Uint8Array: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(buf, 'base16'));
        }
        // ok, tuple seems good.
        tuples.push([
            code,
            addr
        ]);
    }
    return tuples;
}
function cleanPath(str) {
    return '/' + str.trim().split('/').filter((a)=>a).join('/');
}
class ParseError extends Error {
    static name = 'ParseError';
    name = 'ParseError';
    constructor(str){
        super(`Error parsing address: ${str}`);
    }
} //# sourceMappingURL=codec.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "MultiaddrFilter": (()=>MultiaddrFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/convert.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <locals>");
;
;
class MultiaddrFilter {
    multiaddr;
    netmask;
    constructor(input){
        this.multiaddr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["multiaddr"])(input);
        this.netmask = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToIpNet"])(this.multiaddr);
    }
    contains(input) {
        if (input == null) return false;
        const m = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["multiaddr"])(input);
        let ip;
        for (const [code, value] of m.stringTuples()){
            if (code === 4 || code === 41) {
                ip = value;
                break;
            }
        }
        if (ip === undefined) return false;
        return this.netmask.contains(ip);
    }
} //# sourceMappingURL=multiaddr-filter.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @packageDocumentation
 *
 * A standard way to represent addresses that
 *
 * - support any standard network protocol
 * - are self-describing
 * - have a binary packed format
 * - have a nice string representation
 * - encapsulate well
 *
 * @example
 *
 * ```TypeScript
 * import { multiaddr } from '@multiformats/multiaddr'
 *
 * const addr = multiaddr('/ip4/127.0.0.1/udp/1234')
 * // Multiaddr(/ip4/127.0.0.1/udp/1234)
 *
 * addr.bytes
 * // <Uint8Array 04 7f 00 00 01 11 04 d2>
 *
 * addr.toString()
 * // '/ip4/127.0.0.1/udp/1234'
 *
 * addr.protos()
 * // [
 * //   {code: 4, name: 'ip4', size: 32},
 * //   {code: 273, name: 'udp', size: 16}
 * // ]
 *
 * // gives you an object that is friendly with what Node.js core modules expect for addresses
 * addr.nodeAddress()
 * // {
 * //   family: 4,
 * //   port: 1234,
 * //   address: "127.0.0.1"
 * // }
 *
 * addr.encapsulate('/sctp/5678')
 * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)
 * ```
 *
 * ## Resolving DNSADDR addresses
 *
 * [DNSADDR](https://github.com/multiformats/multiaddr/blob/master/protocols/DNSADDR.md) is a spec that allows storing a TXT DNS record that contains a Multiaddr.
 *
 * To resolve DNSADDR addresses, call the `.resolve()` function the multiaddr, optionally passing a `DNS` resolver.
 *
 * DNSADDR addresses can resolve to multiple multiaddrs, since there is no limit to the number of TXT records that can be stored.
 *
 * @example Resolving DNSADDR Multiaddrs
 *
 * ```TypeScript
 * import { multiaddr, resolvers } from '@multiformats/multiaddr'
 * import { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'
 *
 * resolvers.set('dnsaddr', dnsaddrResolver)
 *
 * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')
 *
 * // resolve with a 5s timeout
 * const resolved = await ma.resolve({
 *   signal: AbortSignal.timeout(5000)
 * })
 *
 * console.info(resolved)
 * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]
 * ```
 *
 * @example Using a custom DNS resolver to resolve DNSADDR Multiaddrs
 *
 * See the docs for [@multiformats/dns](https://www.npmjs.com/package/@multiformats/dns) for a full breakdown of how to specify multiple resolvers or resolvers that can be used for specific TLDs.
 *
 * ```TypeScript
 * import { multiaddr } from '@multiformats/multiaddr'
 * import { dns } from '@multiformats/dns'
 * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'
 *
 * const resolver = dns({
 *   resolvers: {
 *     '.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query')
 *   }
 * })
 *
 * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')
 * const resolved = await ma.resolve({
 *  dns: resolver
 * })
 *
 * console.info(resolved)
 * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]
 * ```
 */ __turbopack_context__.s({
    "fromNodeAddress": (()=>fromNodeAddress),
    "fromStringTuples": (()=>fromStringTuples),
    "fromTuples": (()=>fromTuples),
    "isMultiaddr": (()=>isMultiaddr),
    "isName": (()=>isName),
    "multiaddr": (()=>multiaddr),
    "resolvers": (()=>resolvers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/codec.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$multiaddr$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/multiaddr.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$filter$2f$multiaddr$2d$filter$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js [client] (ecmascript)");
;
;
;
const resolvers = new Map();
;
function fromNodeAddress(addr, transport) {
    if (addr == null) {
        throw new Error('requires node address object');
    }
    if (transport == null) {
        throw new Error('requires transport protocol');
    }
    let ip;
    let host = addr.address;
    switch(addr.family){
        case 4:
            ip = 'ip4';
            break;
        case 6:
            ip = 'ip6';
            if (host.includes('%')) {
                const parts = host.split('%');
                if (parts.length !== 2) {
                    throw Error('Multiple ip6 zones in multiaddr');
                }
                host = parts[0];
                const zone = parts[1];
                ip = `/ip6zone/${zone}/ip6`;
            }
            break;
        default:
            throw Error('Invalid addr family, should be 4 or 6.');
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$multiaddr$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Multiaddr"]('/' + [
        ip,
        host,
        transport,
        addr.port
    ].join('/'));
}
function fromTuples(tuples) {
    return multiaddr((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["tuplesToBytes"])(tuples));
}
function fromStringTuples(tuples) {
    return fromTuples((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["stringTuplesToTuples"])(tuples));
}
function isName(addr) {
    if (!isMultiaddr(addr)) {
        return false;
    }
    // if a part of the multiaddr is resolvable, then return true
    return addr.protos().some((proto)=>proto.resolvable);
}
function isMultiaddr(value) {
    return Boolean(value?.[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$multiaddr$2e$js__$5b$client$5d$__$28$ecmascript$29$__["symbol"]]);
}
function multiaddr(addr) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$multiaddr$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Multiaddr"](addr);
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/multiaddr.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* eslint-disable complexity */ __turbopack_context__.s({
    "Multiaddr": (()=>Multiaddr),
    "symbol": (()=>symbol)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/bases/base58.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/multiformats/dist/src/cid.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/equals.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/uint8arrays/dist/src/to-string.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/codec.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <locals>");
;
;
;
;
;
;
;
const inspect = Symbol.for('nodejs.util.inspect.custom');
const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');
const DNS_CODES = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns').code,
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns4').code,
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns6').code,
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('dnsaddr').code
];
class NoAvailableResolverError extends Error {
    constructor(message = 'No available resolver'){
        super(message);
        this.name = 'NoAvailableResolverError';
    }
}
class Multiaddr {
    bytes;
    #string;
    #tuples;
    #stringTuples;
    #path;
    [symbol] = true;
    constructor(addr){
        // default
        if (addr == null) {
            addr = '';
        }
        let parts;
        if (addr instanceof Uint8Array) {
            parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bytesToMultiaddrParts"])(addr);
        } else if (typeof addr === 'string') {
            if (addr.length > 0 && addr.charAt(0) !== '/') {
                throw new Error(`multiaddr "${addr}" must start with a "/"`);
            }
            parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["stringToMultiaddrParts"])(addr);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isMultiaddr"])(addr)) {
            parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["bytesToMultiaddrParts"])(addr.bytes);
        } else {
            throw new Error('addr must be a string, Buffer, or another Multiaddr');
        }
        this.bytes = parts.bytes;
        this.#string = parts.string;
        this.#tuples = parts.tuples;
        this.#stringTuples = parts.stringTuples;
        this.#path = parts.path;
    }
    toString() {
        return this.#string;
    }
    toJSON() {
        return this.toString();
    }
    toOptions() {
        let family;
        let transport;
        let host;
        let port;
        let zone = '';
        const tcp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('tcp');
        const udp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('udp');
        const ip4 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip4');
        const ip6 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip6');
        const dns6 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns6');
        const ip6zone = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip6zone');
        for (const [code, value] of this.stringTuples()){
            if (code === ip6zone.code) {
                zone = `%${value ?? ''}`;
            }
            // default to https when protocol & port are omitted from DNS addrs
            if (DNS_CODES.includes(code)) {
                transport = tcp.name === 'tcp' ? 'tcp' : 'udp';
                port = 443;
                host = `${value ?? ''}${zone}`;
                family = code === dns6.code ? 6 : 4;
            }
            if (code === tcp.code || code === udp.code) {
                transport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(code).name === 'tcp' ? 'tcp' : 'udp';
                port = parseInt(value ?? '');
            }
            if (code === ip4.code || code === ip6.code) {
                transport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(code).name === 'tcp' ? 'tcp' : 'udp';
                host = `${value ?? ''}${zone}`;
                family = code === ip6.code ? 6 : 4;
            }
        }
        if (family == null || transport == null || host == null || port == null) {
            throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
        }
        const opts = {
            family,
            host,
            transport,
            port
        };
        return opts;
    }
    protos() {
        return this.#tuples.map(([code])=>Object.assign({}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(code)));
    }
    protoCodes() {
        return this.#tuples.map(([code])=>code);
    }
    protoNames() {
        return this.#tuples.map(([code])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])(code).name);
    }
    tuples() {
        return this.#tuples.map(([code, value])=>{
            if (value == null) {
                return [
                    code
                ];
            }
            return [
                code,
                value
            ];
        });
    }
    stringTuples() {
        return this.#stringTuples.map(([code, value])=>{
            if (value == null) {
                return [
                    code
                ];
            }
            return [
                code,
                value
            ];
        });
    }
    encapsulate(addr) {
        addr = new Multiaddr(addr);
        return new Multiaddr(this.toString() + addr.toString());
    }
    decapsulate(addr) {
        const addrString = addr.toString();
        const s = this.toString();
        const i = s.lastIndexOf(addrString);
        if (i < 0) {
            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
        }
        return new Multiaddr(s.slice(0, i));
    }
    decapsulateCode(code) {
        const tuples = this.tuples();
        for(let i = tuples.length - 1; i >= 0; i--){
            if (tuples[i][0] === code) {
                return new Multiaddr((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__["tuplesToBytes"])(tuples.slice(0, i)));
            }
        }
        return this;
    }
    getPeerId() {
        try {
            let tuples = [];
            this.stringTuples().forEach(([code, name])=>{
                if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["names"].p2p.code) {
                    tuples.push([
                        code,
                        name
                    ]);
                }
                // if this is a p2p-circuit address, return the target peer id if present
                // not the peer id of the relay
                if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["names"]['p2p-circuit'].code) {
                    tuples = [];
                }
            });
            // Get the last ipfs tuple ['p2p', 'peerid string']
            const tuple = tuples.pop();
            if (tuple?.[1] != null) {
                const peerIdStr = tuple[1];
                // peer id is base58btc encoded string but not multibase encoded so add the `z`
                // prefix so we can validate that it is correctly encoded
                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$client$5d$__$28$ecmascript$29$__["base58btc"].decode(`z${peerIdStr}`), 'base58btc');
                }
                // try to parse peer id as CID
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toString"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(peerIdStr).multihash.bytes, 'base58btc');
            }
            return null;
        } catch (e) {
            return null;
        }
    }
    getPath() {
        return this.#path;
    }
    equals(addr) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$client$5d$__$28$ecmascript$29$__["equals"])(this.bytes, addr.bytes);
    }
    async resolve(options) {
        const resolvableProto = this.protos().find((p)=>p.resolvable);
        // Multiaddr is not resolvable?
        if (resolvableProto == null) {
            return [
                this
            ];
        }
        const resolver = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["resolvers"].get(resolvableProto.name);
        if (resolver == null) {
            throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`);
        }
        const result = await resolver(this, options);
        return result.map((str)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["multiaddr"])(str));
    }
    nodeAddress() {
        const options = this.toOptions();
        if (options.transport !== 'tcp' && options.transport !== 'udp') {
            throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
        }
        return {
            family: options.family,
            address: options.host,
            port: options.port
        };
    }
    isThinWaistAddress(addr) {
        const protos = (addr ?? this).protos();
        if (protos.length !== 2) {
            return false;
        }
        if (protos[0].code !== 4 && protos[0].code !== 41) {
            return false;
        }
        if (protos[1].code !== 6 && protos[1].code !== 273) {
            return false;
        }
        return true;
    }
    /**
     * Returns Multiaddr as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```js
     * import { multiaddr } from '@multiformats/multiaddr'
     *
     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
     * ```
     */ [inspect]() {
        return `Multiaddr(${this.#string})`;
    }
} //# sourceMappingURL=multiaddr.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/codec.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$multiaddr$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/multiaddr.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$filter$2f$multiaddr$2d$filter$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/index.js [client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript) <export getProtocol as protocols>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "protocols": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getProtocol"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2d$to$2d$uri$2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/multiaddr-to-uri/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [client] (ecmascript)");
}}),
}]);

//# sourceMappingURL=node_modules_%40multiformats_f14da4ff._.js.map